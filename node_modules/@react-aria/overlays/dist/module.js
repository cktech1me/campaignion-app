import _babelRuntimeHelpersEsmObjectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _domHelpersStyle from "dom-helpers/style";
import _domHelpersQueryOffset from "dom-helpers/query/offset";
import _domHelpersQueryPosition from "dom-helpers/query/position";
import _domHelpersQueryScrollLeft from "dom-helpers/query/scrollLeft";
import _domHelpersQueryScrollTop from "dom-helpers/query/scrollTop";
import _domHelpersOwnerDocument from "dom-helpers/ownerDocument";
import _react, { useEffect, useState, useContext } from "react";
import { useLocale, useMessageFormatter } from "@react-aria/i18n";
import { useFocusWithin, useInteractOutside } from "@react-aria/interactions";
import { useId } from "@react-aria/utils";
import _babelRuntimeHelpersEsmInteropRequireDefault from "@babel/runtime/helpers/esm/interopRequireDefault";
import { VisuallyHidden } from "@react-aria/visually-hidden";
const $a7a15b8408ba1e3bb5fd405f8090c511$var$AXIS = {
  top: 'top',
  bottom: 'top',
  left: 'left',
  right: 'left'
};
const $a7a15b8408ba1e3bb5fd405f8090c511$var$FLIPPED_DIRECTION = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
const $a7a15b8408ba1e3bb5fd405f8090c511$var$CROSS_AXIS = {
  top: 'left',
  left: 'top'
};
const $a7a15b8408ba1e3bb5fd405f8090c511$var$AXIS_SIZE = {
  top: 'height',
  left: 'width'
};
const $a7a15b8408ba1e3bb5fd405f8090c511$var$PARSED_PLACEMENT_CACHE = {};

function $a7a15b8408ba1e3bb5fd405f8090c511$var$getContainerDimensions(containerNode) {
  let width = 0,
      height = 0,
      top = 0,
      left = 0;
  let scroll = {};

  if (containerNode.tagName === 'BODY') {
    width = window.innerWidth;
    height = window.innerHeight;
    scroll.top = _domHelpersQueryScrollTop(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollLeft(containerNode);
  } else {
    ({
      width,
      height,
      top,
      left
    } = _domHelpersQueryOffset(containerNode));
    scroll.top = _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(containerNode);
  }

  return {
    width,
    height,
    scroll,
    top,
    left
  };
}

function $a7a15b8408ba1e3bb5fd405f8090c511$var$getScroll(node) {
  return {
    top: node.scrollTop,
    left: node.scrollLeft,
    width: node.scrollWidth,
    height: node.scrollHeight
  };
}

function $a7a15b8408ba1e3bb5fd405f8090c511$var$getDelta(axis, offset, size, containerDimensions, padding) {
  let containerScroll = containerDimensions.scroll[axis];
  let containerHeight = containerDimensions[$a7a15b8408ba1e3bb5fd405f8090c511$var$AXIS_SIZE[axis]];
  let startEdgeOffset = offset - padding - containerScroll;
  let endEdgeOffset = offset + padding - containerScroll + size;

  if (startEdgeOffset < 0) {
    return -startEdgeOffset;
  } else if (endEdgeOffset > containerHeight) {
    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
  } else {
    return 0;
  }
}

function $a7a15b8408ba1e3bb5fd405f8090c511$var$getMargins(node) {
  let style = window.getComputedStyle(node);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}

function $a7a15b8408ba1e3bb5fd405f8090c511$var$parsePlacement(input) {
  if ($a7a15b8408ba1e3bb5fd405f8090c511$var$PARSED_PLACEMENT_CACHE[input]) {
    return $a7a15b8408ba1e3bb5fd405f8090c511$var$PARSED_PLACEMENT_CACHE[input];
  }

  let [placement, crossPlacement] = input.split(' ');
  let axis = $a7a15b8408ba1e3bb5fd405f8090c511$var$AXIS[placement] || 'right';
  let crossAxis = $a7a15b8408ba1e3bb5fd405f8090c511$var$CROSS_AXIS[axis];

  if (!$a7a15b8408ba1e3bb5fd405f8090c511$var$AXIS[crossPlacement]) {
    crossPlacement = 'center';
  }

  let size = $a7a15b8408ba1e3bb5fd405f8090c511$var$AXIS_SIZE[axis];
  let crossSize = $a7a15b8408ba1e3bb5fd405f8090c511$var$AXIS_SIZE[crossAxis];
  $a7a15b8408ba1e3bb5fd405f8090c511$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  };
  return $a7a15b8408ba1e3bb5fd405f8090c511$var$PARSED_PLACEMENT_CACHE[input];
}

function $a7a15b8408ba1e3bb5fd405f8090c511$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset) {
  let {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  } = placementInfo;
  let position = {};
  position[crossAxis] = childOffset[crossAxis] + crossOffset;

  if (crossPlacement === 'center') {
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  } else if (crossPlacement !== crossAxis) {
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  } // Ensure overlay sticks to target(ignore for overlays smaller than target)


  if (childOffset[crossSize] < overlaySize[crossSize]) {
    let positionForPositiveSideOverflow = Math.min(position[crossAxis], childOffset[crossAxis]);
    position[crossAxis] = Math.max(positionForPositiveSideOverflow, childOffset[crossAxis] - overlaySize[crossSize] + childOffset[crossSize]);
  } // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.


  if (placement === axis) {
    position[$a7a15b8408ba1e3bb5fd405f8090c511$var$FLIPPED_DIRECTION[axis]] = Math.floor(boundaryDimensions[size] - childOffset[axis] - offset);
  } else {
    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);
  }

  return position;
}

function $a7a15b8408ba1e3bb5fd405f8090c511$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
  return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top + containerOffsetWithBoundary.top - position.top - margins.top - margins.bottom - padding) : Math.max(0, childOffset.top - boundaryDimensions.top - boundaryDimensions.scroll.top - containerOffsetWithBoundary.top - margins.top - margins.bottom - padding);
}

function $a7a15b8408ba1e3bb5fd405f8090c511$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let {
    placement,
    axis,
    size
  } = placementInfo;

  if (placement === axis) {
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$a7a15b8408ba1e3bb5fd405f8090c511$var$FLIPPED_DIRECTION[axis]] - padding);
  }

  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$a7a15b8408ba1e3bb5fd405f8090c511$var$FLIPPED_DIRECTION[axis]] - padding);
}

function $a7a15b8408ba1e3bb5fd405f8090c511$export$calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset) {
  let placementInfo = $a7a15b8408ba1e3bb5fd405f8090c511$var$parsePlacement(placementInput);
  let {
    size,
    crossAxis,
    crossSize,
    placement,
    crossPlacement
  } = placementInfo;
  let position = $a7a15b8408ba1e3bb5fd405f8090c511$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset);
  let normalizedOffset = offset;
  let space = $a7a15b8408ba1e3bb5fd405f8090c511$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo); // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip

  if (flip && scrollSize[size] > space) {
    let flippedPlacementInfo = $a7a15b8408ba1e3bb5fd405f8090c511$var$parsePlacement("".concat($a7a15b8408ba1e3bb5fd405f8090c511$var$FLIPPED_DIRECTION[placement], " ").concat(crossPlacement));
    let flippedPosition = $a7a15b8408ba1e3bb5fd405f8090c511$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, -1 * offset, crossOffset);
    let flippedSpace = $a7a15b8408ba1e3bb5fd405f8090c511$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo); // If the available space for the flipped position is greater than the original available space, flip.

    if (flippedSpace > space) {
      placementInfo = flippedPlacementInfo;
      position = flippedPosition;
      normalizedOffset = -1 * offset;
    }
  }

  let delta = $a7a15b8408ba1e3bb5fd405f8090c511$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let maxHeight = $a7a15b8408ba1e3bb5fd405f8090c511$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position = $a7a15b8408ba1e3bb5fd405f8090c511$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset);
  delta = $a7a15b8408ba1e3bb5fd405f8090c511$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let arrowPosition = {};
  arrowPosition[crossAxis] = childOffset[crossSize] > overlaySize[crossSize] ? null : childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;
  return {
    position,
    maxHeight: maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}

function $a7a15b8408ba1e3bb5fd405f8090c511$export$calculatePosition(opts) {
  let {
    placement,
    targetNode,
    overlayNode,
    scrollNode,
    padding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset
  } = opts;
  let container = overlayNode.offsetParent || document.body;
  let isBodyContainer = container.tagName === 'BODY';
  let childOffset = isBodyContainer ? _domHelpersQueryOffset(targetNode) : _domHelpersQueryPosition(targetNode, container);

  if (!isBodyContainer) {
    childOffset.top += parseInt(_domHelpersStyle(targetNode, 'marginTop'), 10) || 0;
    childOffset.left += parseInt(_domHelpersStyle(targetNode, 'marginLeft'), 10) || 0;
  }

  let overlaySize = _domHelpersQueryOffset(overlayNode);

  let margins = $a7a15b8408ba1e3bb5fd405f8090c511$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $a7a15b8408ba1e3bb5fd405f8090c511$var$getScroll(scrollNode);
  let boundaryDimensions = $a7a15b8408ba1e3bb5fd405f8090c511$var$getContainerDimensions(boundaryElement);
  let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? _domHelpersQueryOffset(container) : _domHelpersQueryPosition(container, boundaryElement);
  return $a7a15b8408ba1e3bb5fd405f8090c511$export$calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset);
}

export function useOverlayPosition(props) {
  let {
    direction
  } = useLocale();
  let {
    targetRef,
    overlayRef,
    scrollRef = overlayRef,
    placement = 'bottom',
    containerPadding = 12,
    shouldFlip = true,
    boundaryElement = document.body,
    offset = 0,
    crossOffset = 0,
    shouldUpdatePosition = true,
    isOpen = true
  } = props;
  let [position, setPosition] = useState({
    position: {},
    arrowOffsetLeft: undefined,
    arrowOffsetTop: undefined,
    maxHeight: undefined,
    placement: undefined
  });
  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction];

  let updatePosition = () => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current) {
      return;
    }

    setPosition($a7a15b8408ba1e3bb5fd405f8090c511$export$calculatePosition({
      placement: $c9ef3c3b0f65fb04532747ca520480bd$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset
    }));
  }; // Update position when anything changes


  useEffect(updatePosition, deps); // Update position on window resize

  $c9ef3c3b0f65fb04532747ca520480bd$var$useResize(updatePosition);
  return {
    overlayProps: {
      style: _babelRuntimeHelpersEsmObjectSpread({
        position: 'absolute',
        zIndex: 100000
      }, position.position, {
        maxHeight: position.maxHeight
      })
    },
    placement: position.placement,
    arrowProps: {
      style: {
        left: position.arrowOffsetLeft,
        top: position.arrowOffsetTop
      }
    }
  };
}

function $c9ef3c3b0f65fb04532747ca520480bd$var$useResize(onResize) {
  useEffect(() => {
    window.addEventListener('resize', onResize, false);
    return () => {
      window.removeEventListener('resize', onResize, false);
    };
  }, [onResize]);
}

function $c9ef3c3b0f65fb04532747ca520480bd$var$translateRTL(position, direction) {
  if (direction === 'rtl') {
    return position.replace('start', 'right').replace('end', 'left');
  }

  return position.replace('start', 'left').replace('end', 'right');
}

const $b2a5d64f455c1cea3e640329611b5019$var$visibleOverlays = [];
export function useOverlay(props) {
  let {
    ref,
    onClose,
    shouldCloseOnBlur,
    isOpen,
    isDismissable = false
  } = props; // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.

  useEffect(() => {
    if (isOpen) {
      $b2a5d64f455c1cea3e640329611b5019$var$visibleOverlays.push(ref);
    }

    return () => {
      let index = $b2a5d64f455c1cea3e640329611b5019$var$visibleOverlays.indexOf(ref);

      if (index >= 0) {
        $b2a5d64f455c1cea3e640329611b5019$var$visibleOverlays.splice(index, 1);
      }
    };
  }, [isOpen, ref]); // Only hide the overlay when it is the topmost visible overlay in the stack.

  let onHide = () => {
    if ($b2a5d64f455c1cea3e640329611b5019$var$visibleOverlays[$b2a5d64f455c1cea3e640329611b5019$var$visibleOverlays.length - 1] === ref && onClose) {
      onClose();
    }
  }; // Handle the escape key


  let onKeyDown = e => {
    if (e.key === 'Escape') {
      e.preventDefault();
      onHide();
    }
  }; // Handle clicking outside the overlay to close it


  useInteractOutside({
    ref,
    onInteractOutside: isDismissable ? onHide : null
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: () => {
      onClose();
    }
  });
  return {
    overlayProps: _babelRuntimeHelpersEsmObjectSpread({
      onKeyDown
    }, focusWithinProps)
  };
}
export function useOverlayTrigger(props) {
  let {
    ref,
    type,
    onClose,
    isOpen
  } = props; // When scrolling a parent scrollable region of the trigger (other than the body),
  // we hide the popover. Otherwise, its position would be incorrect.

  useEffect(() => {
    if (!isOpen) {
      return;
    }

    let onScroll = e => {
      // Ignore if scrolling an scrollable region outside the trigger's tree.
      let target = e.target;

      if (!ref.current || !target.contains(ref.current)) {
        return;
      }

      if (onClose) {
        onClose();
      }
    };

    window.addEventListener('scroll', onScroll, true);
    return () => {
      window.removeEventListener('scroll', onScroll, true);
    };
  }, [isOpen, onClose, ref]); // Aria 1.1 supports multiple values for aria-haspopup other than just menus.
  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
  // However, we only add it for menus for now because screen readers often 
  // announce it as a menu even for other values.

  let ariaHasPopup = undefined;

  if (type === 'menu') {
    ariaHasPopup = true;
  } else if (type === 'listbox') {
    ariaHasPopup = 'listbox';
  }

  let overlayId = useId();
  return {
    triggerProps: {
      'aria-haspopup': ariaHasPopup,
      'aria-expanded': isOpen,
      'aria-controls': isOpen ? overlayId : null
    },
    overlayProps: {
      id: overlayId
    }
  };
}
export function usePreventScroll() {
  // Add overflow: hidden to the body on mount, and restore on unmount.
  useEffect(() => {
    let overflow = document.body.style.overflow;
    let paddingRight = document.body.style.paddingRight;
    document.body.style.paddingRight = window.innerWidth - document.documentElement.clientWidth + 'px';
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = overflow;
      document.body.style.paddingRight = paddingRight;
    };
  }, []);
}

const $ecb46f23eb4e6d44c8f5586824df633$var$Context = _react.createContext(null); // Each ModalProvider tracks how many modals are open in its subtree. On mount, the modals
// This is done recursively so that all parent providers are incremented and decremented.
// If the modal count is greater than zero, we add `aria-hidden` to this provider to hide its
// like portals, which can cause the React tree and the DOM tree to differ significantly in structure.
// TODO: maybe move this?


export function ModalProvider(props) {
  let {
    children
  } = props;
  let parent = useContext($ecb46f23eb4e6d44c8f5586824df633$var$Context);
  let [modalCount, setModalCount] = useState(parent ? parent.modalCount : 0);
  let context = {
    parent,
    modalCount,

    addModal() {
      setModalCount(count => count + 1);

      if (parent) {
        parent.addModal();
      }
    },

    removeModal() {
      setModalCount(count => count - 1);

      if (parent) {
        parent.removeModal();
      }
    }

  };
  return (/*#__PURE__*/_react.createElement($ecb46f23eb4e6d44c8f5586824df633$var$Context.Provider, {
      value: context
    }, children)
  );
}
export function useModalProvider() {
  let context = useContext($ecb46f23eb4e6d44c8f5586824df633$var$Context);
  return {
    modalProviderProps: {
      'aria-hidden': context && context.modalCount > 0 ? true : null
    }
  };
}
export function useModal() {
  // Add aria-hidden to all parent providers on mount, and restore on unmount.
  let context = useContext($ecb46f23eb4e6d44c8f5586824df633$var$Context);

  if (!context) {
    throw new Error('Modal is not contained within a provider');
  }

  useEffect(() => {
    if (!context || !context.parent) {
      return;
    } // The immediate context is from the provider containing this modal, so we only
    // want to trigger aria-hidden on its parents not on the modal provider itself.


    context.parent.addModal();
    return () => {
      if (context && context.parent) {
        context.parent.removeModal();
      }
    };
  }, [context, context.parent]);
}
// ASSET: /Users/govett/dev/react-spectrum/packages/@react-aria/overlays/intl/en-US.json
var $a5782fa3d68797eace1f6521053f5a2$exports = {};
$a5782fa3d68797eace1f6521053f5a2$exports = JSON.parse("{\"dismiss\":\"Dismiss\"}");

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// @ts-ignore
const $a8d78eb517ca4cfc6a6a116b05a$var$intlMessages = {
  "en-US": _babelRuntimeHelpersEsmInteropRequireDefault($a5782fa3d68797eace1f6521053f5a2$exports).default
};
export function DismissButton(props) {
  let {
    onDismiss
  } = props;
  let formatMessage = useMessageFormatter($a8d78eb517ca4cfc6a6a116b05a$var$intlMessages);

  let onClick = () => {
    if (onDismiss) {
      onDismiss();
    }
  };

  return (/*#__PURE__*/_react.createElement(VisuallyHidden, null, /*#__PURE__*/_react.createElement("button", {
      tabIndex: -1,
      "aria-label": formatMessage('dismiss'),
      onClick: onClick
    }))
  );
}