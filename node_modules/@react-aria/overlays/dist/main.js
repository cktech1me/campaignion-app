var _babelRuntimeHelpersObjectSpread = $parcel$interopDefault(require("@babel/runtime/helpers/objectSpread2"));

var _babelRuntimeHelpersSlicedToArray = $parcel$interopDefault(require("@babel/runtime/helpers/slicedToArray"));

var _domHelpersStyle = $parcel$interopDefault(require("dom-helpers/style"));

var _domHelpersQueryOffset = $parcel$interopDefault(require("dom-helpers/query/offset"));

var _domHelpersQueryPosition = $parcel$interopDefault(require("dom-helpers/query/position"));

var _domHelpersQueryScrollLeft = $parcel$interopDefault(require("dom-helpers/query/scrollLeft"));

var _domHelpersQueryScrollTop = $parcel$interopDefault(require("dom-helpers/query/scrollTop"));

var _domHelpersOwnerDocument = $parcel$interopDefault(require("dom-helpers/ownerDocument"));

var _react2 = require("react");

var _react = $parcel$interopDefault(_react2);

var useEffect = _react2.useEffect;
var useState = _react2.useState;
var useContext = _react2.useContext;

var _temp = require("@react-aria/i18n");

var useLocale = _temp.useLocale;
var useMessageFormatter = _temp.useMessageFormatter;

var _temp2 = require("@react-aria/interactions");

var useFocusWithin = _temp2.useFocusWithin;
var useInteractOutside = _temp2.useInteractOutside;

var useId = require("@react-aria/utils").useId;

var _babelRuntimeHelpersInteropRequireDefault = $parcel$interopDefault(require("@babel/runtime/helpers/interopRequireDefault"));

var VisuallyHidden = require("@react-aria/visually-hidden").VisuallyHidden;

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

var $c71210c8e671eacb38d16acaa9713c$var$AXIS = {
  top: 'top',
  bottom: 'top',
  left: 'left',
  right: 'left'
};
var $c71210c8e671eacb38d16acaa9713c$var$FLIPPED_DIRECTION = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
var $c71210c8e671eacb38d16acaa9713c$var$CROSS_AXIS = {
  top: 'left',
  left: 'top'
};
var $c71210c8e671eacb38d16acaa9713c$var$AXIS_SIZE = {
  top: 'height',
  left: 'width'
};
var $c71210c8e671eacb38d16acaa9713c$var$PARSED_PLACEMENT_CACHE = {};

function $c71210c8e671eacb38d16acaa9713c$var$getContainerDimensions(containerNode) {
  var width = 0,
      height = 0,
      top = 0,
      left = 0;
  var scroll = {};

  if (containerNode.tagName === 'BODY') {
    width = window.innerWidth;
    height = window.innerHeight;
    scroll.top = _domHelpersQueryScrollTop(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollLeft(containerNode);
  } else {
    var _getOffset = _domHelpersQueryOffset(containerNode);

    width = _getOffset.width;
    height = _getOffset.height;
    top = _getOffset.top;
    left = _getOffset.left;
    scroll.top = _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(containerNode);
  }

  return {
    width: width,
    height: height,
    scroll: scroll,
    top: top,
    left: left
  };
}

function $c71210c8e671eacb38d16acaa9713c$var$getScroll(node) {
  return {
    top: node.scrollTop,
    left: node.scrollLeft,
    width: node.scrollWidth,
    height: node.scrollHeight
  };
}

function $c71210c8e671eacb38d16acaa9713c$var$getDelta(axis, offset, size, containerDimensions, padding) {
  var containerScroll = containerDimensions.scroll[axis];
  var containerHeight = containerDimensions[$c71210c8e671eacb38d16acaa9713c$var$AXIS_SIZE[axis]];
  var startEdgeOffset = offset - padding - containerScroll;
  var endEdgeOffset = offset + padding - containerScroll + size;

  if (startEdgeOffset < 0) {
    return -startEdgeOffset;
  } else if (endEdgeOffset > containerHeight) {
    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
  } else {
    return 0;
  }
}

function $c71210c8e671eacb38d16acaa9713c$var$getMargins(node) {
  var style = window.getComputedStyle(node);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}

function $c71210c8e671eacb38d16acaa9713c$var$parsePlacement(input) {
  if ($c71210c8e671eacb38d16acaa9713c$var$PARSED_PLACEMENT_CACHE[input]) {
    return $c71210c8e671eacb38d16acaa9713c$var$PARSED_PLACEMENT_CACHE[input];
  }

  var _input$split = input.split(' '),
      _input$split2 = _babelRuntimeHelpersSlicedToArray(_input$split, 2),
      placement = _input$split2[0],
      crossPlacement = _input$split2[1];

  var axis = $c71210c8e671eacb38d16acaa9713c$var$AXIS[placement] || 'right';
  var crossAxis = $c71210c8e671eacb38d16acaa9713c$var$CROSS_AXIS[axis];

  if (!$c71210c8e671eacb38d16acaa9713c$var$AXIS[crossPlacement]) {
    crossPlacement = 'center';
  }

  var size = $c71210c8e671eacb38d16acaa9713c$var$AXIS_SIZE[axis];
  var crossSize = $c71210c8e671eacb38d16acaa9713c$var$AXIS_SIZE[crossAxis];
  $c71210c8e671eacb38d16acaa9713c$var$PARSED_PLACEMENT_CACHE[input] = {
    placement: placement,
    crossPlacement: crossPlacement,
    axis: axis,
    crossAxis: crossAxis,
    size: size,
    crossSize: crossSize
  };
  return $c71210c8e671eacb38d16acaa9713c$var$PARSED_PLACEMENT_CACHE[input];
}

function $c71210c8e671eacb38d16acaa9713c$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset) {
  var placement = placementInfo.placement,
      crossPlacement = placementInfo.crossPlacement,
      axis = placementInfo.axis,
      crossAxis = placementInfo.crossAxis,
      size = placementInfo.size,
      crossSize = placementInfo.crossSize;
  var position = {};
  position[crossAxis] = childOffset[crossAxis] + crossOffset;

  if (crossPlacement === 'center') {
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  } else if (crossPlacement !== crossAxis) {
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  } // Ensure overlay sticks to target(ignore for overlays smaller than target)


  if (childOffset[crossSize] < overlaySize[crossSize]) {
    var positionForPositiveSideOverflow = Math.min(position[crossAxis], childOffset[crossAxis]);
    position[crossAxis] = Math.max(positionForPositiveSideOverflow, childOffset[crossAxis] - overlaySize[crossSize] + childOffset[crossSize]);
  } // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.


  if (placement === axis) {
    position[$c71210c8e671eacb38d16acaa9713c$var$FLIPPED_DIRECTION[axis]] = Math.floor(boundaryDimensions[size] - childOffset[axis] - offset);
  } else {
    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);
  }

  return position;
}

function $c71210c8e671eacb38d16acaa9713c$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
  return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top + containerOffsetWithBoundary.top - position.top - margins.top - margins.bottom - padding) : Math.max(0, childOffset.top - boundaryDimensions.top - boundaryDimensions.scroll.top - containerOffsetWithBoundary.top - margins.top - margins.bottom - padding);
}

function $c71210c8e671eacb38d16acaa9713c$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  var placement = placementInfo.placement,
      axis = placementInfo.axis,
      size = placementInfo.size;

  if (placement === axis) {
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$c71210c8e671eacb38d16acaa9713c$var$FLIPPED_DIRECTION[axis]] - padding);
  }

  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$c71210c8e671eacb38d16acaa9713c$var$FLIPPED_DIRECTION[axis]] - padding);
}

function $c71210c8e671eacb38d16acaa9713c$export$calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset) {
  var placementInfo = $c71210c8e671eacb38d16acaa9713c$var$parsePlacement(placementInput);
  var _placementInfo = placementInfo,
      size = _placementInfo.size,
      crossAxis = _placementInfo.crossAxis,
      crossSize = _placementInfo.crossSize,
      placement = _placementInfo.placement,
      crossPlacement = _placementInfo.crossPlacement;
  var position = $c71210c8e671eacb38d16acaa9713c$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset);
  var normalizedOffset = offset;
  var space = $c71210c8e671eacb38d16acaa9713c$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo); // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip

  if (flip && scrollSize[size] > space) {
    var flippedPlacementInfo = $c71210c8e671eacb38d16acaa9713c$var$parsePlacement("".concat($c71210c8e671eacb38d16acaa9713c$var$FLIPPED_DIRECTION[placement], " ").concat(crossPlacement));
    var flippedPosition = $c71210c8e671eacb38d16acaa9713c$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, -1 * offset, crossOffset);
    var flippedSpace = $c71210c8e671eacb38d16acaa9713c$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo); // If the available space for the flipped position is greater than the original available space, flip.

    if (flippedSpace > space) {
      placementInfo = flippedPlacementInfo;
      position = flippedPosition;
      normalizedOffset = -1 * offset;
    }
  }

  var delta = $c71210c8e671eacb38d16acaa9713c$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  var maxHeight = $c71210c8e671eacb38d16acaa9713c$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position = $c71210c8e671eacb38d16acaa9713c$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset);
  delta = $c71210c8e671eacb38d16acaa9713c$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  var arrowPosition = {};
  arrowPosition[crossAxis] = childOffset[crossSize] > overlaySize[crossSize] ? null : childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;
  return {
    position: position,
    maxHeight: maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}

function $c71210c8e671eacb38d16acaa9713c$export$calculatePosition(opts) {
  var placement = opts.placement,
      targetNode = opts.targetNode,
      overlayNode = opts.overlayNode,
      scrollNode = opts.scrollNode,
      padding = opts.padding,
      shouldFlip = opts.shouldFlip,
      boundaryElement = opts.boundaryElement,
      offset = opts.offset,
      crossOffset = opts.crossOffset;
  var container = overlayNode.offsetParent || document.body;
  var isBodyContainer = container.tagName === 'BODY';
  var childOffset = isBodyContainer ? _domHelpersQueryOffset(targetNode) : _domHelpersQueryPosition(targetNode, container);

  if (!isBodyContainer) {
    childOffset.top += parseInt(_domHelpersStyle(targetNode, 'marginTop'), 10) || 0;
    childOffset.left += parseInt(_domHelpersStyle(targetNode, 'marginLeft'), 10) || 0;
  }

  var overlaySize = _domHelpersQueryOffset(overlayNode);

  var margins = $c71210c8e671eacb38d16acaa9713c$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  var scrollSize = $c71210c8e671eacb38d16acaa9713c$var$getScroll(scrollNode);
  var boundaryDimensions = $c71210c8e671eacb38d16acaa9713c$var$getContainerDimensions(boundaryElement);
  var containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? _domHelpersQueryOffset(container) : _domHelpersQueryPosition(container, boundaryElement);
  return $c71210c8e671eacb38d16acaa9713c$export$calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset);
}

function useOverlayPosition(props) {
  var _useLocale = useLocale(),
      direction = _useLocale.direction;

  var targetRef = props.targetRef,
      overlayRef = props.overlayRef,
      _props$scrollRef = props.scrollRef,
      scrollRef = _props$scrollRef === void 0 ? overlayRef : _props$scrollRef,
      _props$placement = props.placement,
      placement = _props$placement === void 0 ? 'bottom' : _props$placement,
      _props$containerPaddi = props.containerPadding,
      containerPadding = _props$containerPaddi === void 0 ? 12 : _props$containerPaddi,
      _props$shouldFlip = props.shouldFlip,
      shouldFlip = _props$shouldFlip === void 0 ? true : _props$shouldFlip,
      _props$boundaryElemen = props.boundaryElement,
      boundaryElement = _props$boundaryElemen === void 0 ? document.body : _props$boundaryElemen,
      _props$offset = props.offset,
      offset = _props$offset === void 0 ? 0 : _props$offset,
      _props$crossOffset = props.crossOffset,
      crossOffset = _props$crossOffset === void 0 ? 0 : _props$crossOffset,
      _props$shouldUpdatePo = props.shouldUpdatePosition,
      shouldUpdatePosition = _props$shouldUpdatePo === void 0 ? true : _props$shouldUpdatePo,
      _props$isOpen = props.isOpen,
      isOpen = _props$isOpen === void 0 ? true : _props$isOpen;

  var _useState = useState({
    position: {},
    arrowOffsetLeft: undefined,
    arrowOffsetTop: undefined,
    maxHeight: undefined,
    placement: undefined
  }),
      _useState2 = _babelRuntimeHelpersSlicedToArray(_useState, 2),
      position = _useState2[0],
      setPosition = _useState2[1];

  var deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction];

  var updatePosition = function updatePosition() {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current) {
      return;
    }

    setPosition($c71210c8e671eacb38d16acaa9713c$export$calculatePosition({
      placement: $bbbcb442362e3abca1b1d54b0282db6$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip: shouldFlip,
      boundaryElement: boundaryElement,
      offset: offset,
      crossOffset: crossOffset
    }));
  }; // Update position when anything changes


  useEffect(updatePosition, deps); // Update position on window resize

  $bbbcb442362e3abca1b1d54b0282db6$var$useResize(updatePosition);
  return {
    overlayProps: {
      style: _babelRuntimeHelpersObjectSpread({
        position: 'absolute',
        zIndex: 100000
      }, position.position, {
        maxHeight: position.maxHeight
      })
    },
    placement: position.placement,
    arrowProps: {
      style: {
        left: position.arrowOffsetLeft,
        top: position.arrowOffsetTop
      }
    }
  };
}

exports.useOverlayPosition = useOverlayPosition;

function $bbbcb442362e3abca1b1d54b0282db6$var$useResize(onResize) {
  useEffect(function () {
    window.addEventListener('resize', onResize, false);
    return function () {
      window.removeEventListener('resize', onResize, false);
    };
  }, [onResize]);
}

function $bbbcb442362e3abca1b1d54b0282db6$var$translateRTL(position, direction) {
  if (direction === 'rtl') {
    return position.replace('start', 'right').replace('end', 'left');
  }

  return position.replace('start', 'left').replace('end', 'right');
}

var $c8bcdeb24249303262637ef18287e$var$visibleOverlays = [];

function useOverlay(props) {
  var ref = props.ref,
      onClose = props.onClose,
      shouldCloseOnBlur = props.shouldCloseOnBlur,
      isOpen = props.isOpen,
      _props$isDismissable = props.isDismissable,
      isDismissable = _props$isDismissable === void 0 ? false : _props$isDismissable; // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.

  useEffect(function () {
    if (isOpen) {
      $c8bcdeb24249303262637ef18287e$var$visibleOverlays.push(ref);
    }

    return function () {
      var index = $c8bcdeb24249303262637ef18287e$var$visibleOverlays.indexOf(ref);

      if (index >= 0) {
        $c8bcdeb24249303262637ef18287e$var$visibleOverlays.splice(index, 1);
      }
    };
  }, [isOpen, ref]); // Only hide the overlay when it is the topmost visible overlay in the stack.

  var onHide = function onHide() {
    if ($c8bcdeb24249303262637ef18287e$var$visibleOverlays[$c8bcdeb24249303262637ef18287e$var$visibleOverlays.length - 1] === ref && onClose) {
      onClose();
    }
  }; // Handle the escape key


  var onKeyDown = function onKeyDown(e) {
    if (e.key === 'Escape') {
      e.preventDefault();
      onHide();
    }
  }; // Handle clicking outside the overlay to close it


  useInteractOutside({
    ref: ref,
    onInteractOutside: isDismissable ? onHide : null
  });

  var _useFocusWithin = useFocusWithin({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: function onBlurWithin() {
      onClose();
    }
  }),
      focusWithinProps = _useFocusWithin.focusWithinProps;

  return {
    overlayProps: _babelRuntimeHelpersObjectSpread({
      onKeyDown: onKeyDown
    }, focusWithinProps)
  };
}

exports.useOverlay = useOverlay;

function useOverlayTrigger(props) {
  var ref = props.ref,
      type = props.type,
      onClose = props.onClose,
      isOpen = props.isOpen; // When scrolling a parent scrollable region of the trigger (other than the body),
  // we hide the popover. Otherwise, its position would be incorrect.

  useEffect(function () {
    if (!isOpen) {
      return;
    }

    var onScroll = function onScroll(e) {
      // Ignore if scrolling an scrollable region outside the trigger's tree.
      var target = e.target;

      if (!ref.current || !target.contains(ref.current)) {
        return;
      }

      if (onClose) {
        onClose();
      }
    };

    window.addEventListener('scroll', onScroll, true);
    return function () {
      window.removeEventListener('scroll', onScroll, true);
    };
  }, [isOpen, onClose, ref]); // Aria 1.1 supports multiple values for aria-haspopup other than just menus.
  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
  // However, we only add it for menus for now because screen readers often 
  // announce it as a menu even for other values.

  var ariaHasPopup = undefined;

  if (type === 'menu') {
    ariaHasPopup = true;
  } else if (type === 'listbox') {
    ariaHasPopup = 'listbox';
  }

  var overlayId = useId();
  return {
    triggerProps: {
      'aria-haspopup': ariaHasPopup,
      'aria-expanded': isOpen,
      'aria-controls': isOpen ? overlayId : null
    },
    overlayProps: {
      id: overlayId
    }
  };
}

exports.useOverlayTrigger = useOverlayTrigger;

function usePreventScroll() {
  // Add overflow: hidden to the body on mount, and restore on unmount.
  useEffect(function () {
    var overflow = document.body.style.overflow;
    var paddingRight = document.body.style.paddingRight;
    document.body.style.paddingRight = window.innerWidth - document.documentElement.clientWidth + 'px';
    document.body.style.overflow = 'hidden';
    return function () {
      document.body.style.overflow = overflow;
      document.body.style.paddingRight = paddingRight;
    };
  }, []);
}

exports.usePreventScroll = usePreventScroll;

var $ba69ad1f216584417ad7a03be330d7$var$Context = _react.createContext(null); // Each ModalProvider tracks how many modals are open in its subtree. On mount, the modals
// trigger `addModal` to increment the count, and trigger `removeModal` on unmount to decrement it.
// This is done recursively so that all parent providers are incremented and decremented.
// If the modal count is greater than zero, we add `aria-hidden` to this provider to hide its
// subtree from screen readers. This is done using React context in order to account for things
// like portals, which can cause the React tree and the DOM tree to differ significantly in structure.
// TODO: maybe move this?


function ModalProvider(props) {
  var children = props.children;
  var parent = useContext($ba69ad1f216584417ad7a03be330d7$var$Context);

  var _useState = useState(parent ? parent.modalCount : 0),
      _useState2 = _babelRuntimeHelpersSlicedToArray(_useState, 2),
      modalCount = _useState2[0],
      setModalCount = _useState2[1];

  var context = {
    parent: parent,
    modalCount: modalCount,
    addModal: function addModal() {
      setModalCount(function (count) {
        return count + 1;
      });

      if (parent) {
        parent.addModal();
      }
    },
    removeModal: function removeModal() {
      setModalCount(function (count) {
        return count - 1;
      });

      if (parent) {
        parent.removeModal();
      }
    }
  };
  return (/*#__PURE__*/_react.createElement($ba69ad1f216584417ad7a03be330d7$var$Context.Provider, {
      value: context
    }, children)
  );
}

exports.ModalProvider = ModalProvider;

function useModalProvider() {
  var context = useContext($ba69ad1f216584417ad7a03be330d7$var$Context);
  return {
    modalProviderProps: {
      'aria-hidden': context && context.modalCount > 0 ? true : null
    }
  };
}

exports.useModalProvider = useModalProvider;

function useModal() {
  // Add aria-hidden to all parent providers on mount, and restore on unmount.
  var context = useContext($ba69ad1f216584417ad7a03be330d7$var$Context);

  if (!context) {
    throw new Error('Modal is not contained within a provider');
  }

  useEffect(function () {
    if (!context || !context.parent) {
      return;
    } // The immediate context is from the provider containing this modal, so we only
    // want to trigger aria-hidden on its parents not on the modal provider itself.


    context.parent.addModal();
    return function () {
      if (context && context.parent) {
        context.parent.removeModal();
      }
    };
  }, [context, context.parent]);
}

exports.useModal = useModal;
// ASSET: /Users/govett/dev/react-spectrum/packages/@react-aria/overlays/intl/en-US.json
var $e6ccb56748e38458ac53f3f41e894$exports = {};
$e6ccb56748e38458ac53f3f41e894$exports = JSON.parse("{\"dismiss\":\"Dismiss\"}");

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// @ts-ignore
var $dc1d75ab9958d677be46b941d9a53f2$var$intlMessages = {
  "en-US": _babelRuntimeHelpersInteropRequireDefault($e6ccb56748e38458ac53f3f41e894$exports).default
};

function DismissButton(props) {
  var onDismiss = props.onDismiss;
  var formatMessage = useMessageFormatter($dc1d75ab9958d677be46b941d9a53f2$var$intlMessages);

  var onClick = function onClick() {
    if (onDismiss) {
      onDismiss();
    }
  };

  return (/*#__PURE__*/_react.createElement(VisuallyHidden, null, /*#__PURE__*/_react.createElement("button", {
      tabIndex: -1,
      "aria-label": formatMessage('dismiss'),
      onClick: onClick
    }))
  );
}

exports.DismissButton = DismissButton;