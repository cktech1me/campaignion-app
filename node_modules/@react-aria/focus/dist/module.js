import { focusWithoutScrolling, mergeProps } from "@react-aria/utils";
import _react, { useContext, useEffect, useLayoutEffect, useRef, useState } from "react";
import _babelRuntimeHelpersEsmObjectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classnames from "classnames";
import { useFocus, useFocusVisible, useFocusWithin, useKeyboard } from "@react-aria/interactions";

const $a00625b63ff86478b58931762d548$var$FocusContext = _react.createContext(null);

let $a00625b63ff86478b58931762d548$var$activeScope = null;
let $a00625b63ff86478b58931762d548$var$scopes = new Set(); // This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:
// https://github.com/reactjs/rfcs/pull/109
// For now, it relies on the DOM tree order rather than the React tree order, and is probably
// less optimized for performance.

export function FocusScope(props) {
  let {
    children,
    contain,
    restoreFocus,
    autoFocus
  } = props;
  let startRef = useRef();
  let endRef = useRef();
  let scopeRef = useRef([]);
  useLayoutEffect(() => {
    // Find all rendered nodes between the sentinels and add them to the scope.
    let node = startRef.current.nextSibling;
    let nodes = [];

    while (node && node !== endRef.current) {
      nodes.push(node);
      node = node.nextSibling;
    }

    scopeRef.current = nodes;
    $a00625b63ff86478b58931762d548$var$scopes.add(scopeRef);
    return () => {
      $a00625b63ff86478b58931762d548$var$scopes.delete(scopeRef);
    };
  }, [children]);
  $a00625b63ff86478b58931762d548$var$useFocusContainment(scopeRef, contain);
  $a00625b63ff86478b58931762d548$var$useRestoreFocus(scopeRef, restoreFocus, contain);
  $a00625b63ff86478b58931762d548$var$useAutoFocus(scopeRef, autoFocus);
  let focusManager = $a00625b63ff86478b58931762d548$var$createFocusManager(scopeRef);
  return (/*#__PURE__*/_react.createElement($a00625b63ff86478b58931762d548$var$FocusContext.Provider, {
      value: focusManager
    }, /*#__PURE__*/_react.createElement("span", {
      hidden: true,
      ref: startRef
    }), children, /*#__PURE__*/_react.createElement("span", {
      hidden: true,
      ref: endRef
    }))
  );
}
export function useFocusManager() {
  return useContext($a00625b63ff86478b58931762d548$var$FocusContext);
}

function $a00625b63ff86478b58931762d548$var$createFocusManager(scopeRef) {
  return {
    focusNext(opts = {}) {
      let node = opts.from || document.activeElement;
      let focusable = $a00625b63ff86478b58931762d548$var$getFocusableElementsInScope(scopeRef.current, opts);
      let nextNode = focusable.find(n => !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY)));

      if (!nextNode && opts.wrap) {
        nextNode = focusable[0];
      }

      if (nextNode) {
        nextNode.focus();
      }

      return nextNode;
    },

    focusPrevious(opts = {}) {
      let node = opts.from || document.activeElement;
      let focusable = $a00625b63ff86478b58931762d548$var$getFocusableElementsInScope(scopeRef.current, opts).reverse();
      let previousNode = focusable.find(n => !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY)));

      if (!previousNode && opts.wrap) {
        previousNode = focusable[0];
      }

      if (previousNode) {
        previousNode.focus();
      }

      return previousNode;
    }

  };
}

const $a00625b63ff86478b58931762d548$var$focusableElements = ['input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]'];
const $a00625b63ff86478b58931762d548$var$FOCUSABLE_ELEMENT_SELECTOR = $a00625b63ff86478b58931762d548$var$focusableElements.join(',') + ',[tabindex]';
$a00625b63ff86478b58931762d548$var$focusableElements.push('[tabindex]:not([tabindex="-1"])');
const $a00625b63ff86478b58931762d548$var$TABBABLE_ELEMENT_SELECTOR = $a00625b63ff86478b58931762d548$var$focusableElements.join(':not([tabindex="-1"]),');

function $a00625b63ff86478b58931762d548$var$getFocusableElementsInScope(scope, opts) {
  let res = [];
  let selector = opts.tabbable ? $a00625b63ff86478b58931762d548$var$TABBABLE_ELEMENT_SELECTOR : $a00625b63ff86478b58931762d548$var$FOCUSABLE_ELEMENT_SELECTOR;

  for (let node of scope) {
    if (node.matches(selector)) {
      res.push(node);
    }

    res.push(...Array.from(node.querySelectorAll(selector)));
  }

  return res;
}

function $a00625b63ff86478b58931762d548$var$useFocusContainment(scopeRef, contain) {
  let focusedNode = useRef();
  useEffect(() => {
    let scope = scopeRef.current;

    if (!contain) {
      return;
    } // Handle the Tab key to contain focus within the scope


    let onKeyDown = e => {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      let focusedElement = document.activeElement;

      if (!$a00625b63ff86478b58931762d548$var$isElementInScope(focusedElement, scope)) {
        return;
      }

      let elements = $a00625b63ff86478b58931762d548$var$getFocusableElementsInScope(scope, {
        tabbable: true
      });
      let position = elements.indexOf(focusedElement);
      let lastPosition = elements.length - 1;
      let nextElement = null;

      if (e.shiftKey) {
        if (position <= 0) {
          nextElement = elements[lastPosition];
        } else {
          nextElement = elements[position - 1];
        }
      } else {
        if (position === lastPosition) {
          nextElement = elements[0];
        } else {
          nextElement = elements[position + 1];
        }
      }

      e.preventDefault();

      if (nextElement) {
        $a00625b63ff86478b58931762d548$var$focusElement(nextElement);
      }
    };

    let onFocus = e => {
      // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
      // restore focus to the previously focused node or the first tabbable element in the active scope.
      let isInAnyScope = $a00625b63ff86478b58931762d548$var$isElementInAnyScope(e.target, $a00625b63ff86478b58931762d548$var$scopes);

      if (!isInAnyScope) {
        if (focusedNode.current) {
          focusedNode.current.focus();
        } else if ($a00625b63ff86478b58931762d548$var$activeScope) {
          $a00625b63ff86478b58931762d548$var$focusFirstInScope($a00625b63ff86478b58931762d548$var$activeScope.current);
        }
      } else {
        e.stopPropagation();
        $a00625b63ff86478b58931762d548$var$activeScope = scopeRef;
        focusedNode.current = e.target;
      }
    };

    let onBlur = e => {
      e.stopPropagation();
      let isInAnyScope = $a00625b63ff86478b58931762d548$var$isElementInAnyScope(e.relatedTarget, $a00625b63ff86478b58931762d548$var$scopes);

      if (!isInAnyScope) {
        $a00625b63ff86478b58931762d548$var$activeScope = scopeRef;
        focusedNode.current = e.target; // Firefox doesn't shift focus back to the Dialog properly without this 

        requestAnimationFrame(() => {
          focusedNode.current.focus();
        });
      }
    };

    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('focusin', onFocus, false);
    scope.forEach(element => element.addEventListener('focusin', onFocus, false));
    scope.forEach(element => element.addEventListener('focusout', onBlur, false));
    return () => {
      document.removeEventListener('keydown', onKeyDown, false);
      document.removeEventListener('focusin', onFocus, false);
      scope.forEach(element => element.removeEventListener('focusin', onFocus, false));
      scope.forEach(element => element.removeEventListener('focusout', onBlur, false));
    };
  }, [scopeRef, contain]);
}

function $a00625b63ff86478b58931762d548$var$isElementInAnyScope(element, scopes) {
  for (let scope of scopes.values()) {
    if ($a00625b63ff86478b58931762d548$var$isElementInScope(element, scope.current)) {
      return true;
    }
  }

  return false;
}

function $a00625b63ff86478b58931762d548$var$isElementInScope(element, scope) {
  return scope.some(node => node.contains(element));
}

function $a00625b63ff86478b58931762d548$var$focusElement(element) {
  if (element != null) {
    try {
      focusWithoutScrolling(element);
    } catch (err) {// ignore
    }
  }
}

function $a00625b63ff86478b58931762d548$var$focusFirstInScope(scope) {
  let elements = $a00625b63ff86478b58931762d548$var$getFocusableElementsInScope(scope, {
    tabbable: true
  });
  $a00625b63ff86478b58931762d548$var$focusElement(elements[0]);
}

function $a00625b63ff86478b58931762d548$var$useAutoFocus(scopeRef, autoFocus) {
  useEffect(() => {
    if (autoFocus) {
      $a00625b63ff86478b58931762d548$var$activeScope = scopeRef;

      if (!$a00625b63ff86478b58931762d548$var$isElementInScope(document.activeElement, $a00625b63ff86478b58931762d548$var$activeScope.current)) {
        $a00625b63ff86478b58931762d548$var$focusFirstInScope(scopeRef.current);
      }
    }
  }, [scopeRef, autoFocus]);
}

function $a00625b63ff86478b58931762d548$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
  useLayoutEffect(() => {
    let scope = scopeRef.current;
    let nodeToRestore = document.activeElement; // Handle the Tab key so that tabbing out of the scope goes to the next element
    // after the node that had focus when the scope mounted. This is important when
    // using portals for overlays, so that focus goes to the expected element when
    // tabbing out of the overlay.

    let onKeyDown = e => {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      let focusedElement = document.activeElement;

      if (!$a00625b63ff86478b58931762d548$var$isElementInScope(focusedElement, scope)) {
        return;
      } // Create a DOM tree walker that matches all tabbable elements


      let walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, {
        acceptNode(node) {
          if (node.matches($a00625b63ff86478b58931762d548$var$TABBABLE_ELEMENT_SELECTOR)) {
            return NodeFilter.FILTER_ACCEPT;
          }

          return NodeFilter.FILTER_SKIP;
        }

      }, false); // Find the next tabbable element after the currently focused element

      walker.currentNode = focusedElement;
      let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode(); // If there is no next element, or it is outside the current scope, move focus to the
      // next element after the node to restore to instead.

      if ((!nextElement || !$a00625b63ff86478b58931762d548$var$isElementInScope(nextElement, scope)) && nodeToRestore) {
        walker.currentNode = nodeToRestore;
        nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
        e.preventDefault();

        if (nextElement) {
          nextElement.focus();
        } else {
          // If there is no next element, blur the focused element to move focus to the body.
          focusedElement.blur();
        }
      }
    };

    if (!contain) {
      document.addEventListener('keydown', onKeyDown, false);
    }

    return () => {
      if (!contain) {
        document.removeEventListener('keydown', onKeyDown, false);
      }

      if (restoreFocus && nodeToRestore && $a00625b63ff86478b58931762d548$var$isElementInScope(document.activeElement, scope)) {
        requestAnimationFrame(() => {
          if (document.body.contains(nodeToRestore)) {
            $a00625b63ff86478b58931762d548$var$focusElement(nodeToRestore);
          }
        });
      }
    };
  }, [scopeRef, restoreFocus, contain]);
}

export function FocusRing(props) {
  let {
    children,
    focusClass,
    focusRingClass,
    within
  } = props;
  let [isFocused, setFocused] = useState(false);
  let [isFocusWithin, setFocusWithin] = useState(false);
  let {
    isFocusVisible
  } = useFocusVisible(props);
  let {
    focusProps
  } = useFocus({
    isDisabled: within,
    onFocusChange: setFocused,
    onFocus: e => e.continuePropagation(),
    onBlur: e => e.continuePropagation()
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !within,
    onFocusWithinChange: setFocusWithin,
    onFocusWithin: e => e.continuePropagation(),
    onBlurWithin: e => e.continuePropagation()
  });

  let child = _react.Children.only(children);

  return _react.cloneElement(child, mergeProps(child.props, _babelRuntimeHelpersEsmObjectSpread({}, within ? focusWithinProps : focusProps, {
    className: _classnames({
      [focusClass || '']: within ? isFocusWithin : isFocused,
      [focusRingClass || '']: (within ? isFocusWithin : isFocused) && isFocusVisible
    })
  })));
}
export function useFocusable(props, domRef) {
  let {
    focusProps
  } = useFocus(props);
  let {
    keyboardProps
  } = useKeyboard(props);
  useEffect(() => {
    if (props.autoFocus && domRef && domRef.current) {
      domRef.current.focus();
    }
  }, [props.autoFocus, domRef]);
  return {
    focusableProps: mergeProps(focusProps, keyboardProps)
  };
}