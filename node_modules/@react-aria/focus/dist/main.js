var _babelRuntimeHelpersToConsumableArray = $parcel$interopDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _temp = require("@react-aria/utils");

var focusWithoutScrolling = _temp.focusWithoutScrolling;
var mergeProps = _temp.mergeProps;

var _react2 = require("react");

var _react = $parcel$interopDefault(_react2);

var useContext = _react2.useContext;
var useEffect = _react2.useEffect;
var useLayoutEffect = _react2.useLayoutEffect;
var useRef = _react2.useRef;
var useState = _react2.useState;

var _babelRuntimeHelpersDefineProperty = $parcel$interopDefault(require("@babel/runtime/helpers/defineProperty"));

var _babelRuntimeHelpersObjectSpread = $parcel$interopDefault(require("@babel/runtime/helpers/objectSpread2"));

var _babelRuntimeHelpersSlicedToArray = $parcel$interopDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classnames = $parcel$interopDefault(require("classnames"));

var _temp2 = require("@react-aria/interactions");

var useFocus = _temp2.useFocus;
var useFocusVisible = _temp2.useFocusVisible;
var useFocusWithin = _temp2.useFocusWithin;
var useKeyboard = _temp2.useKeyboard;

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$_createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = $d3981abf5e4a9c633e711ab7782f0c73$var$_unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return $d3981abf5e4a9c633e711ab7782f0c73$var$_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $d3981abf5e4a9c633e711ab7782f0c73$var$_arrayLikeToArray(o, minLen);
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var $d3981abf5e4a9c633e711ab7782f0c73$var$FocusContext = _react.createContext(null);

var $d3981abf5e4a9c633e711ab7782f0c73$var$activeScope = null;
var $d3981abf5e4a9c633e711ab7782f0c73$var$scopes = new Set(); // This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:
// https://github.com/reactjs/rfcs/pull/109
// For now, it relies on the DOM tree order rather than the React tree order, and is probably
// less optimized for performance.

function FocusScope(props) {
  var children = props.children,
      contain = props.contain,
      restoreFocus = props.restoreFocus,
      autoFocus = props.autoFocus;
  var startRef = useRef();
  var endRef = useRef();
  var scopeRef = useRef([]);
  useLayoutEffect(function () {
    // Find all rendered nodes between the sentinels and add them to the scope.
    var node = startRef.current.nextSibling;
    var nodes = [];

    while (node && node !== endRef.current) {
      nodes.push(node);
      node = node.nextSibling;
    }

    scopeRef.current = nodes;
    $d3981abf5e4a9c633e711ab7782f0c73$var$scopes.add(scopeRef);
    return function () {
      $d3981abf5e4a9c633e711ab7782f0c73$var$scopes.delete(scopeRef);
    };
  }, [children]);
  $d3981abf5e4a9c633e711ab7782f0c73$var$useFocusContainment(scopeRef, contain);
  $d3981abf5e4a9c633e711ab7782f0c73$var$useRestoreFocus(scopeRef, restoreFocus, contain);
  $d3981abf5e4a9c633e711ab7782f0c73$var$useAutoFocus(scopeRef, autoFocus);
  var focusManager = $d3981abf5e4a9c633e711ab7782f0c73$var$createFocusManager(scopeRef);
  return (/*#__PURE__*/_react.createElement($d3981abf5e4a9c633e711ab7782f0c73$var$FocusContext.Provider, {
      value: focusManager
    }, /*#__PURE__*/_react.createElement("span", {
      hidden: true,
      ref: startRef
    }), children, /*#__PURE__*/_react.createElement("span", {
      hidden: true,
      ref: endRef
    }))
  );
}

exports.FocusScope = FocusScope;

function useFocusManager() {
  return useContext($d3981abf5e4a9c633e711ab7782f0c73$var$FocusContext);
}

exports.useFocusManager = useFocusManager;

function $d3981abf5e4a9c633e711ab7782f0c73$var$createFocusManager(scopeRef) {
  return {
    focusNext: function focusNext() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var node = opts.from || document.activeElement;
      var focusable = $d3981abf5e4a9c633e711ab7782f0c73$var$getFocusableElementsInScope(scopeRef.current, opts);
      var nextNode = focusable.find(function (n) {
        return !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY));
      });

      if (!nextNode && opts.wrap) {
        nextNode = focusable[0];
      }

      if (nextNode) {
        nextNode.focus();
      }

      return nextNode;
    },
    focusPrevious: function focusPrevious() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var node = opts.from || document.activeElement;
      var focusable = $d3981abf5e4a9c633e711ab7782f0c73$var$getFocusableElementsInScope(scopeRef.current, opts).reverse();
      var previousNode = focusable.find(function (n) {
        return !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY));
      });

      if (!previousNode && opts.wrap) {
        previousNode = focusable[0];
      }

      if (previousNode) {
        previousNode.focus();
      }

      return previousNode;
    }
  };
}

var $d3981abf5e4a9c633e711ab7782f0c73$var$focusableElements = ['input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]'];
var $d3981abf5e4a9c633e711ab7782f0c73$var$FOCUSABLE_ELEMENT_SELECTOR = $d3981abf5e4a9c633e711ab7782f0c73$var$focusableElements.join(',') + ',[tabindex]';
$d3981abf5e4a9c633e711ab7782f0c73$var$focusableElements.push('[tabindex]:not([tabindex="-1"])');
var $d3981abf5e4a9c633e711ab7782f0c73$var$TABBABLE_ELEMENT_SELECTOR = $d3981abf5e4a9c633e711ab7782f0c73$var$focusableElements.join(':not([tabindex="-1"]),');

function $d3981abf5e4a9c633e711ab7782f0c73$var$getFocusableElementsInScope(scope, opts) {
  var res = [];
  var selector = opts.tabbable ? $d3981abf5e4a9c633e711ab7782f0c73$var$TABBABLE_ELEMENT_SELECTOR : $d3981abf5e4a9c633e711ab7782f0c73$var$FOCUSABLE_ELEMENT_SELECTOR;

  var _iterator = $d3981abf5e4a9c633e711ab7782f0c73$var$_createForOfIteratorHelper(scope),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;

      if (node.matches(selector)) {
        res.push(node);
      }

      res.push.apply(res, _babelRuntimeHelpersToConsumableArray(Array.from(node.querySelectorAll(selector))));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return res;
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$useFocusContainment(scopeRef, contain) {
  var focusedNode = useRef();
  useEffect(function () {
    var scope = scopeRef.current;

    if (!contain) {
      return;
    } // Handle the Tab key to contain focus within the scope


    var onKeyDown = function onKeyDown(e) {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      var focusedElement = document.activeElement;

      if (!$d3981abf5e4a9c633e711ab7782f0c73$var$isElementInScope(focusedElement, scope)) {
        return;
      }

      var elements = $d3981abf5e4a9c633e711ab7782f0c73$var$getFocusableElementsInScope(scope, {
        tabbable: true
      });
      var position = elements.indexOf(focusedElement);
      var lastPosition = elements.length - 1;
      var nextElement = null;

      if (e.shiftKey) {
        if (position <= 0) {
          nextElement = elements[lastPosition];
        } else {
          nextElement = elements[position - 1];
        }
      } else {
        if (position === lastPosition) {
          nextElement = elements[0];
        } else {
          nextElement = elements[position + 1];
        }
      }

      e.preventDefault();

      if (nextElement) {
        $d3981abf5e4a9c633e711ab7782f0c73$var$focusElement(nextElement);
      }
    };

    var onFocus = function onFocus(e) {
      // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
      // restore focus to the previously focused node or the first tabbable element in the active scope.
      var isInAnyScope = $d3981abf5e4a9c633e711ab7782f0c73$var$isElementInAnyScope(e.target, $d3981abf5e4a9c633e711ab7782f0c73$var$scopes);

      if (!isInAnyScope) {
        if (focusedNode.current) {
          focusedNode.current.focus();
        } else if ($d3981abf5e4a9c633e711ab7782f0c73$var$activeScope) {
          $d3981abf5e4a9c633e711ab7782f0c73$var$focusFirstInScope($d3981abf5e4a9c633e711ab7782f0c73$var$activeScope.current);
        }
      } else {
        e.stopPropagation();
        $d3981abf5e4a9c633e711ab7782f0c73$var$activeScope = scopeRef;
        focusedNode.current = e.target;
      }
    };

    var onBlur = function onBlur(e) {
      e.stopPropagation();
      var isInAnyScope = $d3981abf5e4a9c633e711ab7782f0c73$var$isElementInAnyScope(e.relatedTarget, $d3981abf5e4a9c633e711ab7782f0c73$var$scopes);

      if (!isInAnyScope) {
        $d3981abf5e4a9c633e711ab7782f0c73$var$activeScope = scopeRef;
        focusedNode.current = e.target; // Firefox doesn't shift focus back to the Dialog properly without this 

        requestAnimationFrame(function () {
          focusedNode.current.focus();
        });
      }
    };

    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('focusin', onFocus, false);
    scope.forEach(function (element) {
      return element.addEventListener('focusin', onFocus, false);
    });
    scope.forEach(function (element) {
      return element.addEventListener('focusout', onBlur, false);
    });
    return function () {
      document.removeEventListener('keydown', onKeyDown, false);
      document.removeEventListener('focusin', onFocus, false);
      scope.forEach(function (element) {
        return element.removeEventListener('focusin', onFocus, false);
      });
      scope.forEach(function (element) {
        return element.removeEventListener('focusout', onBlur, false);
      });
    };
  }, [scopeRef, contain]);
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$isElementInAnyScope(element, scopes) {
  var _iterator2 = $d3981abf5e4a9c633e711ab7782f0c73$var$_createForOfIteratorHelper(scopes.values()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var scope = _step2.value;

      if ($d3981abf5e4a9c633e711ab7782f0c73$var$isElementInScope(element, scope.current)) {
        return true;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return false;
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$isElementInScope(element, scope) {
  return scope.some(function (node) {
    return node.contains(element);
  });
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$focusElement(element) {
  if (element != null) {
    try {
      focusWithoutScrolling(element);
    } catch (err) {// ignore
    }
  }
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$focusFirstInScope(scope) {
  var elements = $d3981abf5e4a9c633e711ab7782f0c73$var$getFocusableElementsInScope(scope, {
    tabbable: true
  });
  $d3981abf5e4a9c633e711ab7782f0c73$var$focusElement(elements[0]);
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$useAutoFocus(scopeRef, autoFocus) {
  useEffect(function () {
    if (autoFocus) {
      $d3981abf5e4a9c633e711ab7782f0c73$var$activeScope = scopeRef;

      if (!$d3981abf5e4a9c633e711ab7782f0c73$var$isElementInScope(document.activeElement, $d3981abf5e4a9c633e711ab7782f0c73$var$activeScope.current)) {
        $d3981abf5e4a9c633e711ab7782f0c73$var$focusFirstInScope(scopeRef.current);
      }
    }
  }, [scopeRef, autoFocus]);
}

function $d3981abf5e4a9c633e711ab7782f0c73$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
  useLayoutEffect(function () {
    var scope = scopeRef.current;
    var nodeToRestore = document.activeElement; // Handle the Tab key so that tabbing out of the scope goes to the next element
    // after the node that had focus when the scope mounted. This is important when
    // using portals for overlays, so that focus goes to the expected element when
    // tabbing out of the overlay.

    var onKeyDown = function onKeyDown(e) {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      var focusedElement = document.activeElement;

      if (!$d3981abf5e4a9c633e711ab7782f0c73$var$isElementInScope(focusedElement, scope)) {
        return;
      } // Create a DOM tree walker that matches all tabbable elements


      var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function acceptNode(node) {
          if (node.matches($d3981abf5e4a9c633e711ab7782f0c73$var$TABBABLE_ELEMENT_SELECTOR)) {
            return NodeFilter.FILTER_ACCEPT;
          }

          return NodeFilter.FILTER_SKIP;
        }
      }, false); // Find the next tabbable element after the currently focused element

      walker.currentNode = focusedElement;
      var nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode(); // If there is no next element, or it is outside the current scope, move focus to the
      // next element after the node to restore to instead.

      if ((!nextElement || !$d3981abf5e4a9c633e711ab7782f0c73$var$isElementInScope(nextElement, scope)) && nodeToRestore) {
        walker.currentNode = nodeToRestore;
        nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
        e.preventDefault();

        if (nextElement) {
          nextElement.focus();
        } else {
          // If there is no next element, blur the focused element to move focus to the body.
          focusedElement.blur();
        }
      }
    };

    if (!contain) {
      document.addEventListener('keydown', onKeyDown, false);
    }

    return function () {
      if (!contain) {
        document.removeEventListener('keydown', onKeyDown, false);
      }

      if (restoreFocus && nodeToRestore && $d3981abf5e4a9c633e711ab7782f0c73$var$isElementInScope(document.activeElement, scope)) {
        requestAnimationFrame(function () {
          if (document.body.contains(nodeToRestore)) {
            $d3981abf5e4a9c633e711ab7782f0c73$var$focusElement(nodeToRestore);
          }
        });
      }
    };
  }, [scopeRef, restoreFocus, contain]);
}

function FocusRing(props) {
  var _classNames;

  var children = props.children,
      focusClass = props.focusClass,
      focusRingClass = props.focusRingClass,
      within = props.within;

  var _useState = useState(false),
      _useState2 = _babelRuntimeHelpersSlicedToArray(_useState, 2),
      isFocused = _useState2[0],
      setFocused = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _babelRuntimeHelpersSlicedToArray(_useState3, 2),
      isFocusWithin = _useState4[0],
      setFocusWithin = _useState4[1];

  var _useFocusVisible = useFocusVisible(props),
      isFocusVisible = _useFocusVisible.isFocusVisible;

  var _useFocus = useFocus({
    isDisabled: within,
    onFocusChange: setFocused,
    onFocus: function onFocus(e) {
      return e.continuePropagation();
    },
    onBlur: function onBlur(e) {
      return e.continuePropagation();
    }
  }),
      focusProps = _useFocus.focusProps;

  var _useFocusWithin = useFocusWithin({
    isDisabled: !within,
    onFocusWithinChange: setFocusWithin,
    onFocusWithin: function onFocusWithin(e) {
      return e.continuePropagation();
    },
    onBlurWithin: function onBlurWithin(e) {
      return e.continuePropagation();
    }
  }),
      focusWithinProps = _useFocusWithin.focusWithinProps;

  var child = _react.Children.only(children);

  return _react.cloneElement(child, mergeProps(child.props, _babelRuntimeHelpersObjectSpread({}, within ? focusWithinProps : focusProps, {
    className: _classnames((_classNames = {}, _babelRuntimeHelpersDefineProperty(_classNames, focusClass || '', within ? isFocusWithin : isFocused), _babelRuntimeHelpersDefineProperty(_classNames, focusRingClass || '', (within ? isFocusWithin : isFocused) && isFocusVisible), _classNames))
  })));
}

exports.FocusRing = FocusRing;

function useFocusable(props, domRef) {
  var _useFocus = useFocus(props),
      focusProps = _useFocus.focusProps;

  var _useKeyboard = useKeyboard(props),
      keyboardProps = _useKeyboard.keyboardProps;

  useEffect(function () {
    if (props.autoFocus && domRef && domRef.current) {
      domRef.current.focus();
    }
  }, [props.autoFocus, domRef]);
  return {
    focusableProps: mergeProps(focusProps, keyboardProps)
  };
}

exports.useFocusable = useFocusable;