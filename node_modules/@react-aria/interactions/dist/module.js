import _babelRuntimeHelpersEsmObjectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import { focusWithoutScrolling, mergeProps } from "@react-aria/utils";
import _react, { useContext, useEffect, useMemo, useRef, useState } from "react";
import _babelRuntimeHelpersEsmObjectSpread from "@babel/runtime/helpers/esm/objectSpread2";

const $dfb1afd42bc5ba853feb46619fe4852d$export$PressResponderContext = _react.createContext(null);

$dfb1afd42bc5ba853feb46619fe4852d$export$PressResponderContext.displayName = 'PressResponderContext';

function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$usePressResponderContext(props) {
  // Consume context from <PressResponder> and merge with props.
  let context = useContext($dfb1afd42bc5ba853feb46619fe4852d$export$PressResponderContext);

  if (context) {
    let {
      register
    } = context,
        contextProps = _babelRuntimeHelpersEsmObjectWithoutProperties(context, ["register"]);

    props = mergeProps(contextProps, props);
    register();
  } // Sync ref from <PressResponder> with ref passed to usePress.


  useEffect(() => {
    if (context && context.ref) {
      context.ref.current = props.ref.current;
      return () => {
        context.ref.current = null;
      };
    }
  }, [context, props.ref]);
  return props;
}

export function usePress(props) {
  let _usePressResponderCon = $d4f8c4e5fbfabc3f0b106b817fa442a7$var$usePressResponderContext(props),
      {
    onPress,
    onPressChange,
    onPressStart,
    onPressEnd,
    onPressUp,
    isDisabled,
    isPressed: isPressedProp,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _
  } = _usePressResponderCon,
      domProps = _babelRuntimeHelpersEsmObjectWithoutProperties(_usePressResponderCon, ["onPress", "onPressChange", "onPressStart", "onPressEnd", "onPressUp", "isDisabled", "isPressed", "ref"]);

  let [isPressed, setPressed] = useState(false);
  let ref = useRef({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    ignoreClickAfterPress: false,
    activePointerId: null,
    target: null,
    isOverTarget: false
  });
  let pressProps = useMemo(() => {
    let state = ref.current;

    let triggerPressStart = (originalEvent, pointerType) => {
      if (isDisabled) {
        return;
      }

      if (onPressStart) {
        onPressStart({
          type: 'pressstart',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }

      if (onPressChange) {
        onPressChange(true);
      }

      setPressed(true);
    };

    let triggerPressEnd = (originalEvent, pointerType, wasPressed = true) => {
      if (isDisabled) {
        return;
      }

      state.ignoreClickAfterPress = true;

      if (onPressEnd) {
        onPressEnd({
          type: 'pressend',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }

      if (onPressChange) {
        onPressChange(false);
      }

      setPressed(false);

      if (onPress && wasPressed) {
        onPress({
          type: 'press',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }
    };

    let triggerPressUp = (originalEvent, pointerType) => {
      if (isDisabled) {
        return;
      }

      if (onPressUp) {
        onPressUp({
          type: 'pressup',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }
    };

    let pressProps = {
      onKeyDown(e) {
        if ($d4f8c4e5fbfabc3f0b106b817fa442a7$var$isValidKeyboardEvent(e.nativeEvent)) {
          e.preventDefault();
          e.stopPropagation(); // If the event is repeating, it may have started on a different element
          // after which focus moved to the current element. Ignore these events and
          // only handle the first key down event.

          if (!state.isPressed && !e.repeat) {
            state.target = e.currentTarget;
            state.isPressed = true;
            triggerPressStart(e, 'keyboard'); // Focus may move before the key up event, so register the event on the document
            // instead of the same element where the key down event occurred.

            document.addEventListener('keyup', onKeyUp, false);
          }
        }
      },

      onKeyUp(e) {
        if ($d4f8c4e5fbfabc3f0b106b817fa442a7$var$isValidKeyboardEvent(e.nativeEvent) && !e.repeat) {
          triggerPressUp($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), 'keyboard');
        }
      },

      onClick(e) {
        if (e && e.button === 0) {
          e.stopPropagation();

          if (isDisabled) {
            e.preventDefault();
          } // If triggered from a screen reader or by using element.click(),
          // trigger as if it were a keyboard click.


          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isVirtualClick(e.nativeEvent)) {
            // Ensure the element receives focus (VoiceOver on iOS does not do this)
            if (!isDisabled) {
              focusWithoutScrolling(e.currentTarget);
            }

            triggerPressStart(e, 'virtual');
            triggerPressUp(e, 'virtual');
            triggerPressEnd(e, 'virtual');
          }

          state.ignoreEmulatedMouseEvents = false;
          state.ignoreClickAfterPress = false;
        }
      }

    };

    let onKeyUp = e => {
      if (state.isPressed && $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isValidKeyboardEvent(e)) {
        e.preventDefault();
        e.stopPropagation();
        state.isPressed = false;
        triggerPressEnd($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), 'keyboard', e.target === state.target);
        document.removeEventListener('keyup', onKeyUp, false); // If the target is a link, trigger the click method to open the URL,
        // but defer triggering pressEnd until onClick event handler.

        if (e.target === state.target && $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isHTMLAnchorLink(state.target) || state.target.getAttribute('role') === 'link') {
          state.target.click();
        }
      }
    }; // Safari on iOS starts selecting text on long press. The only way to avoid this, it seems,
    // is to add user-select: none to the entire page. Adding it to the pressable element prevents
    // that element from being selected, but nearby elements may still receive selection. We add
    // user-select: none on touch start, and remove it again on touch end to prevent this.


    let disableTextSelection = () => {
      state.userSelect = document.documentElement.style.webkitUserSelect;
      document.documentElement.style.webkitUserSelect = 'none';
    };

    let restoreTextSelection = () => {
      // There appears to be a delay on iOS where selection still might occur 
      // after pointer up, so wait a bit before removing user-select.
      setTimeout(() => {
        // Avoid race conditions
        if (!state.isPressed && document.documentElement.style.webkitUserSelect === 'none') {
          document.documentElement.style.webkitUserSelect = state.userSelect || '';
          state.userSelect = null;
        }
      }, 300);
    };

    if (typeof PointerEvent !== 'undefined') {
      pressProps.onPointerDown = e => {
        // Only handle left clicks
        if (e.button !== 0) {
          return;
        } // Due to browser inconsistencies, especially on mobile browsers, we prevent
        // default on pointer down and handle focusing the pressable element ourselves.


        e.preventDefault();
        e.stopPropagation();

        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e.pointerId;
          state.target = e.currentTarget;

          if (!isDisabled) {
            focusWithoutScrolling(e.currentTarget);
          }

          disableTextSelection();
          triggerPressStart(e, e.pointerType);
          document.addEventListener('pointermove', onPointerMove, false);
          document.addEventListener('pointerup', onPointerUp, false);
          document.addEventListener('pointercancel', onPointerCancel, false);
        }
      };

      pressProps.onMouseDown = e => {
        if (e.button === 0) {
          // Chrome and Firefox on touch Windows devices require mouse down events
          // to be canceled in addition to pointer events, or an extra asynchronous
          // focus event will be fired.
          e.preventDefault();
        }
      };

      let unbindEvents = () => {
        document.removeEventListener('pointermove', onPointerMove, false);
        document.removeEventListener('pointerup', onPointerUp, false);
        document.removeEventListener('pointercancel', onPointerCancel, false);
      };

      pressProps.onPointerUp = e => {
        // Only handle left clicks
        // Safari on iOS sometimes fires pointerup events, even
        // when the touch isn't over the target, so double check.
        if (e.button === 0 && $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isOverTarget(e, e.currentTarget)) {
          triggerPressUp(e, e.pointerType);
        }
      }; // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
      // Use pointer move events instead to implement our own hit testing.
      // See https://bugs.webkit.org/show_bug.cgi?id=199803


      let onPointerMove = e => {
        if (e.pointerId !== state.activePointerId) {
          return;
        }

        if ($d4f8c4e5fbfabc3f0b106b817fa442a7$var$isOverTarget(e, state.target)) {
          if (!state.isOverTarget) {
            state.isOverTarget = true;
            triggerPressStart($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), e.pointerType);
          }
        } else if (state.isOverTarget) {
          state.isOverTarget = false;
          triggerPressEnd($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), e.pointerType, false);
        }
      };

      let onPointerUp = e => {
        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
          if ($d4f8c4e5fbfabc3f0b106b817fa442a7$var$isOverTarget(e, state.target)) {
            triggerPressEnd($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), e.pointerType);
          } else if (state.isOverTarget) {
            triggerPressEnd($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), e.pointerType, false);
          }

          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          unbindEvents();
          restoreTextSelection();
        }
      };

      let onPointerCancel = e => {
        if (state.isPressed) {
          if (state.isOverTarget) {
            triggerPressEnd($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), e.pointerType, false);
          }

          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          unbindEvents();
          restoreTextSelection();
        }
      };
    } else {
      pressProps.onMouseDown = e => {
        // Only handle left clicks
        if (e.button !== 0) {
          return;
        } // Due to browser inconsistencies, especially on mobile browsers, we prevent
        // default on mouse down and handle focusing the pressable element ourselves.


        e.preventDefault();
        e.stopPropagation();

        if (state.ignoreEmulatedMouseEvents) {
          return;
        }

        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e.currentTarget;

        if (!isDisabled) {
          focusWithoutScrolling(e.currentTarget);
        }

        triggerPressStart(e, 'mouse');
        document.addEventListener('mouseup', onMouseUp, false);
      };

      pressProps.onMouseEnter = e => {
        e.stopPropagation();

        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
          state.isOverTarget = true;
          triggerPressStart(e, 'mouse');
        }
      };

      pressProps.onMouseLeave = e => {
        e.stopPropagation();

        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
          state.isOverTarget = false;
          triggerPressEnd(e, 'mouse', false);
        }
      };

      pressProps.onMouseUp = e => {
        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {
          triggerPressUp(e, 'mouse');
        }
      };

      let onMouseUp = e => {
        // Only handle left clicks
        if (e.button !== 0) {
          return;
        }

        state.isPressed = false;
        document.removeEventListener('mouseup', onMouseUp, false);

        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }

        if ($d4f8c4e5fbfabc3f0b106b817fa442a7$var$isOverTarget(e, state.target)) {
          triggerPressEnd($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), 'mouse');
        } else if (state.isOverTarget) {
          triggerPressEnd($d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(state.target, e), 'mouse', false);
        }

        state.isOverTarget = false;
      };

      pressProps.onTouchStart = e => {
        e.stopPropagation();
        let touch = $d4f8c4e5fbfabc3f0b106b817fa442a7$var$getTouchFromEvent(e.nativeEvent);

        if (!touch) {
          return;
        }

        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e.currentTarget; // Due to browser inconsistencies, especially on mobile browsers, we prevent default
        // on the emulated mouse event and handle focusing the pressable element ourselves.

        if (!isDisabled) {
          focusWithoutScrolling(e.currentTarget);
        }

        disableTextSelection();
        triggerPressStart(e, 'touch');
        window.addEventListener('scroll', onScroll, true);
      };

      pressProps.onTouchMove = e => {
        e.stopPropagation();

        if (!state.isPressed) {
          return;
        }

        let touch = $d4f8c4e5fbfabc3f0b106b817fa442a7$var$getTouchById(e.nativeEvent, state.activePointerId);

        if (touch && $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isOverTarget(touch, e.currentTarget)) {
          if (!state.isOverTarget) {
            state.isOverTarget = true;
            triggerPressStart(e, 'touch');
          }
        } else if (state.isOverTarget) {
          state.isOverTarget = false;
          triggerPressEnd(e, 'touch', false);
        }
      };

      pressProps.onTouchEnd = e => {
        e.stopPropagation();

        if (!state.isPressed) {
          return;
        }

        let touch = $d4f8c4e5fbfabc3f0b106b817fa442a7$var$getTouchById(e.nativeEvent, state.activePointerId);

        if (touch && $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isOverTarget(touch, e.currentTarget)) {
          triggerPressUp(e, 'touch');
          triggerPressEnd(e, 'touch');
        } else if (state.isOverTarget) {
          triggerPressEnd(e, 'touch', false);
        }

        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        restoreTextSelection();
        window.removeEventListener('scroll', onScroll, true);
      };

      pressProps.onTouchCancel = e => {
        e.stopPropagation();

        if (state.isPressed) {
          cancelTouchEvent(e, 'touch');
        }
      };

      let onScroll = e => {
        if (state.isPressed && e.target.contains(state.target)) {
          cancelTouchEvent({
            currentTarget: state.target,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false
          }, 'touch');
        }
      };

      let cancelTouchEvent = (e, pointerType) => {
        if (state.isOverTarget) {
          triggerPressEnd(e, pointerType, false);
        }

        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        restoreTextSelection();
        window.removeEventListener('scroll', onScroll, true);
      };
    }

    return pressProps;
  }, [onPress, onPressStart, onPressEnd, onPressChange, onPressUp, isDisabled]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: mergeProps(domProps, pressProps)
  };
}

function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isHTMLAnchorLink(target) {
  return target.tagName === 'A' && target.hasAttribute('href');
}

function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isValidKeyboardEvent(event) {
  const {
    key,
    target
  } = event;
  const element = target;
  const {
    tagName,
    isContentEditable
  } = element;
  const role = element.getAttribute('role'); // Accessibility for keyboards. Space and Enter only.
  // "Spacebar" is for IE 11

  return (key === 'Enter' || key === ' ' || key === 'Spacebar') && tagName !== 'INPUT' && tagName !== 'TEXTAREA' && isContentEditable !== true && ( // A link with a valid href should be handled natively,
  // unless it also has role='button' and was triggered using Space.
  !$d4f8c4e5fbfabc3f0b106b817fa442a7$var$isHTMLAnchorLink(element) || role === 'button' && key !== 'Enter') && // An element with role='link' should only trigger with Enter key
  !(role === 'link' && key !== 'Enter');
} // Per: https://github.com/facebook/react/blob/3c713d513195a53788b3f8bb4b70279d68b15bcc/packages/react-interactions/events/src/dom/shared/index.js#L74-L87
// Keyboards, Assitive Technologies, and element.click() all produce a "virtual"
// click event. This is a method of inferring such clicks. Every browser except
// IE 11 only sets a zero value of "detail" for click events that are "virtual".
// However, IE 11 uses a zero value for all click events. For IE 11 we rely on
// the quirk that it produces click events that are of type PointerEvent, and
// where only the "virtual" click lacks a pointerType field.


function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isVirtualClick(event) {
  // JAWS/NVDA with Firefox.
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }

  return event.detail === 0 && !event.pointerType;
}

function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$getTouchFromEvent(event) {
  const {
    targetTouches
  } = event;

  if (targetTouches.length > 0) {
    return targetTouches[0];
  }

  return null;
}

function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$getTouchById(event, pointerId) {
  const changedTouches = event.changedTouches;

  for (let i = 0; i < changedTouches.length; i++) {
    const touch = changedTouches[i];

    if (touch.identifier === pointerId) {
      return touch;
    }
  }

  return null;
}

function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$createEvent(target, e) {
  return {
    currentTarget: target,
    shiftKey: e.shiftKey,
    ctrlKey: e.ctrlKey,
    metaKey: e.metaKey
  };
}

function $d4f8c4e5fbfabc3f0b106b817fa442a7$var$isOverTarget(point, target) {
  let rect = target.getBoundingClientRect();
  return (point.clientX || 0) >= (rect.left || 0) && (point.clientX || 0) <= (rect.right || 0) && (point.clientY || 0) >= (rect.top || 0) && (point.clientY || 0) <= (rect.bottom || 0);
}

export function useInteractOutside(props) {
  let {
    ref,
    onInteractOutside
  } = props;
  let stateRef = useRef({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  let state = stateRef.current;
  useEffect(() => {
    let onPointerDown = e => {
      if ($aa0c64dcd7f02ca42a7bfa03164e6$var$isValidEvent(e, ref)) {
        state.isPointerDown = true;
      }
    }; // Use pointer events if available. Otherwise, fall back to mouse and touch events.


    if (typeof PointerEvent !== 'undefined') {
      let onPointerUp = e => {
        if (state.isPointerDown && onInteractOutside && $aa0c64dcd7f02ca42a7bfa03164e6$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      document.addEventListener('pointerdown', onPointerDown, false);
      document.addEventListener('pointerup', onPointerUp, false);
      return () => {
        document.removeEventListener('pointerdown', onPointerDown, false);
        document.removeEventListener('pointerup', onPointerUp, false);
      };
    } else {
      let onMouseUp = e => {
        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
        } else if (state.isPointerDown && onInteractOutside && $aa0c64dcd7f02ca42a7bfa03164e6$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      let onTouchEnd = e => {
        state.ignoreEmulatedMouseEvents = true;

        if (onInteractOutside && state.isPointerDown && $aa0c64dcd7f02ca42a7bfa03164e6$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      document.addEventListener('mousedown', onPointerDown, false);
      document.addEventListener('mouseup', onMouseUp, false);
      document.addEventListener('touchstart', onPointerDown, false);
      document.addEventListener('touchend', onTouchEnd, false);
      return () => {
        document.removeEventListener('mousedown', onPointerDown, false);
        document.removeEventListener('mouseup', onMouseUp, false);
        document.removeEventListener('touchstart', onPointerDown, false);
        document.removeEventListener('touchend', onTouchEnd, false);
      };
    }
  }, [onInteractOutside, ref, state.ignoreEmulatedMouseEvents, state.isPointerDown]);
}

function $aa0c64dcd7f02ca42a7bfa03164e6$var$isValidEvent(event, ref) {
  if (event.button > 0) {
    return false;
  }

  return ref.current && !ref.current.contains(event.target);
}

export const Pressable = _react.forwardRef((_ref, ref) => {
  let {
    children
  } = _ref,
      props = _babelRuntimeHelpersEsmObjectWithoutProperties(_ref, ["children"]);

  ref = ref || useRef();
  let {
    pressProps
  } = usePress(_babelRuntimeHelpersEsmObjectSpread({}, props, {
    ref
  }));

  let child = _react.Children.only(children);

  return _react.cloneElement(child, // @ts-ignore
  _babelRuntimeHelpersEsmObjectSpread({
    ref
  }, mergeProps(child.props, pressProps)));
});
export const PressResponder = _react.forwardRef((_ref, ref) => {
  let {
    children
  } = _ref,
      props = _babelRuntimeHelpersEsmObjectWithoutProperties(_ref, ["children"]);

  let isRegistered = useRef(false);

  let context = _babelRuntimeHelpersEsmObjectSpread({}, props, {
    ref,

    register() {
      isRegistered.current = true;
    }

  });

  useEffect(() => {
    if (!isRegistered.current) {
      console.warn('A PressResponder was rendered without a pressable child. ' + 'Either call the usePress hook, or wrap your DOM node with <Pressable> component.');
    }
  }, []);
  return (/*#__PURE__*/_react.createElement($dfb1afd42bc5ba853feb46619fe4852d$export$PressResponderContext.Provider, {
      value: context
    }, children)
  );
});

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// This function wraps a React event handler to make stopPropagation the default, and support continuePropagation instead.
function $bf0ab9e2de2515781be699d1ec74e486$export$createEventHandler(handler) {
  if (!handler) {
    return;
  }

  let shouldStopPropagation = true;
  return e => {
    let event = _babelRuntimeHelpersEsmObjectSpread({}, e, {
      preventDefault() {
        e.preventDefault();
      },

      isDefaultPrevented() {
        return e.isDefaultPrevented();
      },

      stopPropagation() {
        console.error('stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.');
      },

      continuePropagation() {
        shouldStopPropagation = false;
      }

    });

    handler(event);

    if (shouldStopPropagation) {
      e.stopPropagation();
    }
  };
}

export function useKeyboard(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: $bf0ab9e2de2515781be699d1ec74e486$export$createEventHandler(props.onKeyDown),
      onKeyUp: $bf0ab9e2de2515781be699d1ec74e486$export$createEventHandler(props.onKeyUp)
    }
  };
}

/**
 * Handles focus events for the immediate target (no children)
 */
export function useFocus(props) {
  if (props.isDisabled) {
    return {
      focusProps: {}
    };
  }

  let onFocus, onBlur;

  if (props.onFocus || props.onFocusChange) {
    onFocus = $bf0ab9e2de2515781be699d1ec74e486$export$createEventHandler(e => {
      if (e.target === e.currentTarget) {
        if (props.onFocus) {
          props.onFocus(e);
        }

        if (props.onFocusChange) {
          props.onFocusChange(true);
        }
      }
    });
  }

  if (props.onBlur || props.onFocusChange) {
    onBlur = $bf0ab9e2de2515781be699d1ec74e486$export$createEventHandler(e => {
      if (e.target === e.currentTarget) {
        if (props.onBlur) {
          props.onBlur(e);
        }

        if (props.onFocusChange) {
          props.onFocusChange(false);
        }
      }
    });
  }

  return {
    focusProps: {
      onFocus,
      onBlur
    }
  };
}

/**
 * Handles focus events for the target and all children
 */
export function useFocusWithin(props) {
  let state = useRef({
    isFocusWithin: false
  }).current;

  if (props.isDisabled) {
    return {
      focusWithinProps: {}
    };
  }

  let onFocus = $bf0ab9e2de2515781be699d1ec74e486$export$createEventHandler(e => {
    if (props.onFocusWithin) {
      props.onFocusWithin(e);
    }

    if (!state.isFocusWithin) {
      if (props.onFocusWithinChange) {
        props.onFocusWithinChange(true);
      }

      state.isFocusWithin = true;
    }
  });
  let onBlur = $bf0ab9e2de2515781be699d1ec74e486$export$createEventHandler(e => {
    // We don't want to trigger onBlurWithin and then immediately onFocusWithin again 
    // when moving focus inside the element. Only trigger if the currentTarget doesn't 
    // include the relatedTarget (where focus is moving).
    if (state.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
      if (props.onBlurWithin) {
        props.onBlurWithin(e);
      }

      if (props.onFocusWithinChange) {
        props.onFocusWithinChange(false);
      }

      state.isFocusWithin = false;
    }
  });
  return {
    focusWithinProps: {
      onFocus: onFocus,
      onBlur: onBlur
    }
  };
}
let $d51c87ad858c3af15dd5d3656d9d713$var$isGlobalFocusVisible = true;
let $d51c87ad858c3af15dd5d3656d9d713$var$changeHandlers = new Set();
let $d51c87ad858c3af15dd5d3656d9d713$var$hasSetupGlobalListeners = false;
let $d51c87ad858c3af15dd5d3656d9d713$var$hasEventBeforeFocus = false;
const $d51c87ad858c3af15dd5d3656d9d713$var$isMac = typeof window !== 'undefined' && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false; // Only Tab or Esc keys will make focus visible on text input elements

const $d51c87ad858c3af15dd5d3656d9d713$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};

function $d51c87ad858c3af15dd5d3656d9d713$var$triggerChangeHandlers(modality, e) {
  for (let handler of $d51c87ad858c3af15dd5d3656d9d713$var$changeHandlers) {
    handler(modality, e);
  }
} // Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible


function $d51c87ad858c3af15dd5d3656d9d713$var$isValidKey(e) {
  return !(e.metaKey || !$d51c87ad858c3af15dd5d3656d9d713$var$isMac && e.altKey || e.ctrlKey);
}

function $d51c87ad858c3af15dd5d3656d9d713$var$handleKeyboardEvent(e) {
  $d51c87ad858c3af15dd5d3656d9d713$var$hasEventBeforeFocus = true;

  if ($d51c87ad858c3af15dd5d3656d9d713$var$isValidKey(e)) {
    $d51c87ad858c3af15dd5d3656d9d713$var$isGlobalFocusVisible = true;
    $d51c87ad858c3af15dd5d3656d9d713$var$triggerChangeHandlers('keyboard', e);
  }
}

function $d51c87ad858c3af15dd5d3656d9d713$var$handlePointerEvent(e) {
  $d51c87ad858c3af15dd5d3656d9d713$var$isGlobalFocusVisible = false;

  if (e.type === 'mousedown' || e.type === 'pointerdown') {
    $d51c87ad858c3af15dd5d3656d9d713$var$hasEventBeforeFocus = true;
    $d51c87ad858c3af15dd5d3656d9d713$var$triggerChangeHandlers('pointer', e);
  }
}

function $d51c87ad858c3af15dd5d3656d9d713$var$handleFocusEvent(e) {
  // If a focus event occurs without a preceding keyboard or pointer event, switch to keyboard modality.
  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
  if (!$d51c87ad858c3af15dd5d3656d9d713$var$hasEventBeforeFocus) {
    $d51c87ad858c3af15dd5d3656d9d713$var$isGlobalFocusVisible = true;
    $d51c87ad858c3af15dd5d3656d9d713$var$triggerChangeHandlers('keyboard', e);
  }

  $d51c87ad858c3af15dd5d3656d9d713$var$hasEventBeforeFocus = false;
} // Setup global event listeners to control when keyboard focus style should be visible


function $d51c87ad858c3af15dd5d3656d9d713$var$setupGlobalFocusEvents() {
  if ($d51c87ad858c3af15dd5d3656d9d713$var$hasSetupGlobalListeners) {
    return;
  } // Programmatic focus() calls shouldn't affect the current input modality.
  // However, we need to detect other cases when a focus event occurs without
  // a preceding user event (e.g. screen reader focus). Overriding the focus
  // method on HTMLElement.prototype is a bit hacky, but works.


  let focus = HTMLElement.prototype.focus;

  HTMLElement.prototype.focus = function () {
    $d51c87ad858c3af15dd5d3656d9d713$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };

  document.addEventListener('keydown', $d51c87ad858c3af15dd5d3656d9d713$var$handleKeyboardEvent, true);
  document.addEventListener('keyup', $d51c87ad858c3af15dd5d3656d9d713$var$handleKeyboardEvent, true);
  document.addEventListener('focus', $d51c87ad858c3af15dd5d3656d9d713$var$handleFocusEvent, true);

  if (typeof PointerEvent !== 'undefined') {
    document.addEventListener('pointerdown', $d51c87ad858c3af15dd5d3656d9d713$var$handlePointerEvent, true);
    document.addEventListener('pointermove', $d51c87ad858c3af15dd5d3656d9d713$var$handlePointerEvent, true);
    document.addEventListener('pointerup', $d51c87ad858c3af15dd5d3656d9d713$var$handlePointerEvent, true);
  } else {
    document.addEventListener('mousedown', $d51c87ad858c3af15dd5d3656d9d713$var$handlePointerEvent, true);
    document.addEventListener('mousemove', $d51c87ad858c3af15dd5d3656d9d713$var$handlePointerEvent, true);
    document.addEventListener('mouseup', $d51c87ad858c3af15dd5d3656d9d713$var$handlePointerEvent, true);
  }

  $d51c87ad858c3af15dd5d3656d9d713$var$hasSetupGlobalListeners = true;
}
/**
 * Manages global focus visible state, and subscribes individual components for updates
 */


export function useFocusVisible(props) {
  $d51c87ad858c3af15dd5d3656d9d713$var$setupGlobalFocusEvents();
  let {
    isTextInput,
    autoFocus
  } = props;
  let [isFocusVisible, setFocusVisible] = useState(autoFocus || $d51c87ad858c3af15dd5d3656d9d713$var$isGlobalFocusVisible);
  useEffect(() => {
    let handler = (modality, e) => {
      // If this is a text input component, don't update the focus visible style when 
      // typing except for when the Tab and Escape keys are pressed.
      if (isTextInput && modality === 'keyboard' && !$d51c87ad858c3af15dd5d3656d9d713$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]) {
        return;
      }

      setFocusVisible($d51c87ad858c3af15dd5d3656d9d713$var$isGlobalFocusVisible);
    };

    $d51c87ad858c3af15dd5d3656d9d713$var$changeHandlers.add(handler);
    return () => {
      $d51c87ad858c3af15dd5d3656d9d713$var$changeHandlers.delete(handler);
    };
  }, [isTextInput]);
  return {
    isFocusVisible
  };
}
export function useHover(props) {
  let {
    onHover,
    onHoverChange,
    onHoverEnd,
    isDisabled
  } = props,
      domProps = _babelRuntimeHelpersEsmObjectWithoutProperties(props, ["onHover", "onHoverChange", "onHoverEnd", "isDisabled"]);

  let hoverProps = useMemo(() => {
    let triggerHoverStart = (event, pointerType) => {
      if (isDisabled) {
        return;
      }

      if (pointerType === 'touch') {
        return;
      }

      let target = event.target;

      if (onHover) {
        onHover({
          type: 'hover',
          target,
          pointerType
        });
      }

      if (onHoverChange) {
        onHoverChange(true);
      }
    };

    let triggerHoverEnd = (event, pointerType) => {
      if (isDisabled) {
        return;
      }

      if (pointerType === 'touch') {
        return;
      }

      let target = event.target;

      if (onHoverEnd) {
        onHoverEnd({
          type: 'hoverend',
          target,
          pointerType
        });
      }

      if (onHoverChange) {
        onHoverChange(false);
      }
    };

    let hoverProps = {};

    if (typeof PointerEvent !== 'undefined') {
      hoverProps.onPointerEnter = e => {
        triggerHoverStart(e, e.pointerType);
      };

      hoverProps.onPointerLeave = e => {
        triggerHoverEnd(e, e.pointerType);
      };
    } else {
      hoverProps.onMouseEnter = e => {
        triggerHoverStart(e, 'mouse');
      };

      hoverProps.onMouseLeave = e => {
        triggerHoverEnd(e, 'mouse');
      };
    }

    return hoverProps;
  }, [onHover, onHoverChange, onHoverEnd, isDisabled]);
  return {
    hoverProps: mergeProps(domProps, hoverProps)
  };
}
export const DOMPropsResponderContext = _react.createContext(null);
export function useDOMPropsResponderContext(props) {
  // Consume context from <DOMPropsResponder> and merge with props.
  let context = useContext(DOMPropsResponderContext);

  if (context) {
    let {
      register
    } = context,
        contextProps = _babelRuntimeHelpersEsmObjectWithoutProperties(context, ["register"]);

    props = mergeProps(contextProps, props);
    register();
  } // Sync ref from <DOMPropsResponder> with ref passed to the useHover hook.


  useEffect(() => {
    if (context && context.ref) {
      context.ref.current = props.ref.current;
      return () => {
        context.ref.current = null;
      };
    }
  }, [context, props.ref]);
  return props;
}
export const DOMPropsResponder = _react.forwardRef((_ref, ref) => {
  let {
    children
  } = _ref,
      props = _babelRuntimeHelpersEsmObjectWithoutProperties(_ref, ["children"]);

  let isRegistered = useRef(false);

  let context = _babelRuntimeHelpersEsmObjectSpread({}, props, {
    ref,

    register() {
      isRegistered.current = true;
    }

  }); // TODO: Think of a more generic message when this replaces the PressResponder as well


  useEffect(() => {
    if (!isRegistered.current) {
      console.warn('A DOMPropsResponder was ultilized without a hoverable DOM node.');
    }
  }, []);
  return (/*#__PURE__*/_react.createElement(DOMPropsResponderContext.Provider, {
      value: context
    }, children)
  );
});
export function useDOMPropsResponder(domRef) {
  let domProps = useDOMPropsResponderContext({
    ref: domRef
  }) || {}; // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars

  const {
    register,
    isDisabled,
    onPress
  } = domProps,
        partialDomProps = _babelRuntimeHelpersEsmObjectWithoutProperties(domProps, ["register", "isDisabled", "onPress"]);

  return {
    contextProps: partialDomProps
  };
}