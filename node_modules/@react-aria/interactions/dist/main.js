var _babelRuntimeHelpersSlicedToArray = $parcel$interopDefault(require("@babel/runtime/helpers/slicedToArray"));

var _babelRuntimeHelpersObjectWithoutProperties = $parcel$interopDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _temp = require("@react-aria/utils");

var focusWithoutScrolling = _temp.focusWithoutScrolling;
var mergeProps = _temp.mergeProps;

var _react2 = require("react");

var _react = $parcel$interopDefault(_react2);

var useContext = _react2.useContext;
var useEffect = _react2.useEffect;
var useMemo = _react2.useMemo;
var useRef = _react2.useRef;
var useState = _react2.useState;

var _babelRuntimeHelpersObjectSpread = $parcel$interopDefault(require("@babel/runtime/helpers/objectSpread2"));

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

var $f0c946772fda863393a370b793f7614$export$PressResponderContext = _react.createContext(null);

$f0c946772fda863393a370b793f7614$export$PressResponderContext.displayName = 'PressResponderContext';

function $d96e234a33d0fc61c9867cbf1a711$var$usePressResponderContext(props) {
  // Consume context from <PressResponder> and merge with props.
  var context = useContext($f0c946772fda863393a370b793f7614$export$PressResponderContext);

  if (context) {
    var register = context.register,
        contextProps = _babelRuntimeHelpersObjectWithoutProperties(context, ["register"]);

    props = mergeProps(contextProps, props);
    register();
  } // Sync ref from <PressResponder> with ref passed to usePress.


  useEffect(function () {
    if (context && context.ref) {
      context.ref.current = props.ref.current;
      return function () {
        context.ref.current = null;
      };
    }
  }, [context, props.ref]);
  return props;
}

function usePress(props) {
  var _usePressResponderCon = $d96e234a33d0fc61c9867cbf1a711$var$usePressResponderContext(props),
      onPress = _usePressResponderCon.onPress,
      onPressChange = _usePressResponderCon.onPressChange,
      onPressStart = _usePressResponderCon.onPressStart,
      onPressEnd = _usePressResponderCon.onPressEnd,
      onPressUp = _usePressResponderCon.onPressUp,
      isDisabled = _usePressResponderCon.isDisabled,
      isPressedProp = _usePressResponderCon.isPressed,
      _ = _usePressResponderCon.ref,
      domProps = _babelRuntimeHelpersObjectWithoutProperties(_usePressResponderCon, ["onPress", "onPressChange", "onPressStart", "onPressEnd", "onPressUp", "isDisabled", "isPressed", "ref"]);

  var _useState = useState(false),
      _useState2 = _babelRuntimeHelpersSlicedToArray(_useState, 2),
      isPressed = _useState2[0],
      setPressed = _useState2[1];

  var ref = useRef({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    ignoreClickAfterPress: false,
    activePointerId: null,
    target: null,
    isOverTarget: false
  });
  var pressProps = useMemo(function () {
    var state = ref.current;

    var triggerPressStart = function triggerPressStart(originalEvent, pointerType) {
      if (isDisabled) {
        return;
      }

      if (onPressStart) {
        onPressStart({
          type: 'pressstart',
          pointerType: pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }

      if (onPressChange) {
        onPressChange(true);
      }

      setPressed(true);
    };

    var triggerPressEnd = function triggerPressEnd(originalEvent, pointerType) {
      var wasPressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (isDisabled) {
        return;
      }

      state.ignoreClickAfterPress = true;

      if (onPressEnd) {
        onPressEnd({
          type: 'pressend',
          pointerType: pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }

      if (onPressChange) {
        onPressChange(false);
      }

      setPressed(false);

      if (onPress && wasPressed) {
        onPress({
          type: 'press',
          pointerType: pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }
    };

    var triggerPressUp = function triggerPressUp(originalEvent, pointerType) {
      if (isDisabled) {
        return;
      }

      if (onPressUp) {
        onPressUp({
          type: 'pressup',
          pointerType: pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }
    };

    var pressProps = {
      onKeyDown: function onKeyDown(e) {
        if ($d96e234a33d0fc61c9867cbf1a711$var$isValidKeyboardEvent(e.nativeEvent)) {
          e.preventDefault();
          e.stopPropagation(); // If the event is repeating, it may have started on a different element
          // after which focus moved to the current element. Ignore these events and
          // only handle the first key down event.

          if (!state.isPressed && !e.repeat) {
            state.target = e.currentTarget;
            state.isPressed = true;
            triggerPressStart(e, 'keyboard'); // Focus may move before the key up event, so register the event on the document
            // instead of the same element where the key down event occurred.

            document.addEventListener('keyup', onKeyUp, false);
          }
        }
      },
      onKeyUp: function onKeyUp(e) {
        if ($d96e234a33d0fc61c9867cbf1a711$var$isValidKeyboardEvent(e.nativeEvent) && !e.repeat) {
          triggerPressUp($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), 'keyboard');
        }
      },
      onClick: function onClick(e) {
        if (e && e.button === 0) {
          e.stopPropagation();

          if (isDisabled) {
            e.preventDefault();
          } // If triggered from a screen reader or by using element.click(),
          // trigger as if it were a keyboard click.


          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && $d96e234a33d0fc61c9867cbf1a711$var$isVirtualClick(e.nativeEvent)) {
            // Ensure the element receives focus (VoiceOver on iOS does not do this)
            if (!isDisabled) {
              focusWithoutScrolling(e.currentTarget);
            }

            triggerPressStart(e, 'virtual');
            triggerPressUp(e, 'virtual');
            triggerPressEnd(e, 'virtual');
          }

          state.ignoreEmulatedMouseEvents = false;
          state.ignoreClickAfterPress = false;
        }
      }
    };

    var onKeyUp = function onKeyUp(e) {
      if (state.isPressed && $d96e234a33d0fc61c9867cbf1a711$var$isValidKeyboardEvent(e)) {
        e.preventDefault();
        e.stopPropagation();
        state.isPressed = false;
        triggerPressEnd($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), 'keyboard', e.target === state.target);
        document.removeEventListener('keyup', onKeyUp, false); // If the target is a link, trigger the click method to open the URL,
        // but defer triggering pressEnd until onClick event handler.

        if (e.target === state.target && $d96e234a33d0fc61c9867cbf1a711$var$isHTMLAnchorLink(state.target) || state.target.getAttribute('role') === 'link') {
          state.target.click();
        }
      }
    }; // Safari on iOS starts selecting text on long press. The only way to avoid this, it seems,
    // is to add user-select: none to the entire page. Adding it to the pressable element prevents
    // that element from being selected, but nearby elements may still receive selection. We add
    // user-select: none on touch start, and remove it again on touch end to prevent this.


    var disableTextSelection = function disableTextSelection() {
      state.userSelect = document.documentElement.style.webkitUserSelect;
      document.documentElement.style.webkitUserSelect = 'none';
    };

    var restoreTextSelection = function restoreTextSelection() {
      // There appears to be a delay on iOS where selection still might occur 
      // after pointer up, so wait a bit before removing user-select.
      setTimeout(function () {
        // Avoid race conditions
        if (!state.isPressed && document.documentElement.style.webkitUserSelect === 'none') {
          document.documentElement.style.webkitUserSelect = state.userSelect || '';
          state.userSelect = null;
        }
      }, 300);
    };

    if (typeof PointerEvent !== 'undefined') {
      pressProps.onPointerDown = function (e) {
        // Only handle left clicks
        if (e.button !== 0) {
          return;
        } // Due to browser inconsistencies, especially on mobile browsers, we prevent
        // default on pointer down and handle focusing the pressable element ourselves.


        e.preventDefault();
        e.stopPropagation();

        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e.pointerId;
          state.target = e.currentTarget;

          if (!isDisabled) {
            focusWithoutScrolling(e.currentTarget);
          }

          disableTextSelection();
          triggerPressStart(e, e.pointerType);
          document.addEventListener('pointermove', onPointerMove, false);
          document.addEventListener('pointerup', onPointerUp, false);
          document.addEventListener('pointercancel', onPointerCancel, false);
        }
      };

      pressProps.onMouseDown = function (e) {
        if (e.button === 0) {
          // Chrome and Firefox on touch Windows devices require mouse down events
          // to be canceled in addition to pointer events, or an extra asynchronous
          // focus event will be fired.
          e.preventDefault();
        }
      };

      var unbindEvents = function unbindEvents() {
        document.removeEventListener('pointermove', onPointerMove, false);
        document.removeEventListener('pointerup', onPointerUp, false);
        document.removeEventListener('pointercancel', onPointerCancel, false);
      };

      pressProps.onPointerUp = function (e) {
        // Only handle left clicks
        // Safari on iOS sometimes fires pointerup events, even
        // when the touch isn't over the target, so double check.
        if (e.button === 0 && $d96e234a33d0fc61c9867cbf1a711$var$isOverTarget(e, e.currentTarget)) {
          triggerPressUp(e, e.pointerType);
        }
      }; // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
      // Use pointer move events instead to implement our own hit testing.
      // See https://bugs.webkit.org/show_bug.cgi?id=199803


      var onPointerMove = function onPointerMove(e) {
        if (e.pointerId !== state.activePointerId) {
          return;
        }

        if ($d96e234a33d0fc61c9867cbf1a711$var$isOverTarget(e, state.target)) {
          if (!state.isOverTarget) {
            state.isOverTarget = true;
            triggerPressStart($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), e.pointerType);
          }
        } else if (state.isOverTarget) {
          state.isOverTarget = false;
          triggerPressEnd($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), e.pointerType, false);
        }
      };

      var onPointerUp = function onPointerUp(e) {
        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
          if ($d96e234a33d0fc61c9867cbf1a711$var$isOverTarget(e, state.target)) {
            triggerPressEnd($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), e.pointerType);
          } else if (state.isOverTarget) {
            triggerPressEnd($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), e.pointerType, false);
          }

          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          unbindEvents();
          restoreTextSelection();
        }
      };

      var onPointerCancel = function onPointerCancel(e) {
        if (state.isPressed) {
          if (state.isOverTarget) {
            triggerPressEnd($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), e.pointerType, false);
          }

          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          unbindEvents();
          restoreTextSelection();
        }
      };
    } else {
      pressProps.onMouseDown = function (e) {
        // Only handle left clicks
        if (e.button !== 0) {
          return;
        } // Due to browser inconsistencies, especially on mobile browsers, we prevent
        // default on mouse down and handle focusing the pressable element ourselves.


        e.preventDefault();
        e.stopPropagation();

        if (state.ignoreEmulatedMouseEvents) {
          return;
        }

        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e.currentTarget;

        if (!isDisabled) {
          focusWithoutScrolling(e.currentTarget);
        }

        triggerPressStart(e, 'mouse');
        document.addEventListener('mouseup', onMouseUp, false);
      };

      pressProps.onMouseEnter = function (e) {
        e.stopPropagation();

        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
          state.isOverTarget = true;
          triggerPressStart(e, 'mouse');
        }
      };

      pressProps.onMouseLeave = function (e) {
        e.stopPropagation();

        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
          state.isOverTarget = false;
          triggerPressEnd(e, 'mouse', false);
        }
      };

      pressProps.onMouseUp = function (e) {
        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {
          triggerPressUp(e, 'mouse');
        }
      };

      var onMouseUp = function onMouseUp(e) {
        // Only handle left clicks
        if (e.button !== 0) {
          return;
        }

        state.isPressed = false;
        document.removeEventListener('mouseup', onMouseUp, false);

        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }

        if ($d96e234a33d0fc61c9867cbf1a711$var$isOverTarget(e, state.target)) {
          triggerPressEnd($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), 'mouse');
        } else if (state.isOverTarget) {
          triggerPressEnd($d96e234a33d0fc61c9867cbf1a711$var$createEvent(state.target, e), 'mouse', false);
        }

        state.isOverTarget = false;
      };

      pressProps.onTouchStart = function (e) {
        e.stopPropagation();
        var touch = $d96e234a33d0fc61c9867cbf1a711$var$getTouchFromEvent(e.nativeEvent);

        if (!touch) {
          return;
        }

        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e.currentTarget; // Due to browser inconsistencies, especially on mobile browsers, we prevent default
        // on the emulated mouse event and handle focusing the pressable element ourselves.

        if (!isDisabled) {
          focusWithoutScrolling(e.currentTarget);
        }

        disableTextSelection();
        triggerPressStart(e, 'touch');
        window.addEventListener('scroll', onScroll, true);
      };

      pressProps.onTouchMove = function (e) {
        e.stopPropagation();

        if (!state.isPressed) {
          return;
        }

        var touch = $d96e234a33d0fc61c9867cbf1a711$var$getTouchById(e.nativeEvent, state.activePointerId);

        if (touch && $d96e234a33d0fc61c9867cbf1a711$var$isOverTarget(touch, e.currentTarget)) {
          if (!state.isOverTarget) {
            state.isOverTarget = true;
            triggerPressStart(e, 'touch');
          }
        } else if (state.isOverTarget) {
          state.isOverTarget = false;
          triggerPressEnd(e, 'touch', false);
        }
      };

      pressProps.onTouchEnd = function (e) {
        e.stopPropagation();

        if (!state.isPressed) {
          return;
        }

        var touch = $d96e234a33d0fc61c9867cbf1a711$var$getTouchById(e.nativeEvent, state.activePointerId);

        if (touch && $d96e234a33d0fc61c9867cbf1a711$var$isOverTarget(touch, e.currentTarget)) {
          triggerPressUp(e, 'touch');
          triggerPressEnd(e, 'touch');
        } else if (state.isOverTarget) {
          triggerPressEnd(e, 'touch', false);
        }

        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        restoreTextSelection();
        window.removeEventListener('scroll', onScroll, true);
      };

      pressProps.onTouchCancel = function (e) {
        e.stopPropagation();

        if (state.isPressed) {
          cancelTouchEvent(e, 'touch');
        }
      };

      var onScroll = function onScroll(e) {
        if (state.isPressed && e.target.contains(state.target)) {
          cancelTouchEvent({
            currentTarget: state.target,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false
          }, 'touch');
        }
      };

      var cancelTouchEvent = function cancelTouchEvent(e, pointerType) {
        if (state.isOverTarget) {
          triggerPressEnd(e, pointerType, false);
        }

        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        restoreTextSelection();
        window.removeEventListener('scroll', onScroll, true);
      };
    }

    return pressProps;
  }, [onPress, onPressStart, onPressEnd, onPressChange, onPressUp, isDisabled]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: mergeProps(domProps, pressProps)
  };
}

exports.usePress = usePress;

function $d96e234a33d0fc61c9867cbf1a711$var$isHTMLAnchorLink(target) {
  return target.tagName === 'A' && target.hasAttribute('href');
}

function $d96e234a33d0fc61c9867cbf1a711$var$isValidKeyboardEvent(event) {
  var key = event.key,
      target = event.target;
  var element = target;
  var tagName = element.tagName,
      isContentEditable = element.isContentEditable;
  var role = element.getAttribute('role'); // Accessibility for keyboards. Space and Enter only.
  // "Spacebar" is for IE 11

  return (key === 'Enter' || key === ' ' || key === 'Spacebar') && tagName !== 'INPUT' && tagName !== 'TEXTAREA' && isContentEditable !== true && ( // A link with a valid href should be handled natively,
  // unless it also has role='button' and was triggered using Space.
  !$d96e234a33d0fc61c9867cbf1a711$var$isHTMLAnchorLink(element) || role === 'button' && key !== 'Enter') && // An element with role='link' should only trigger with Enter key
  !(role === 'link' && key !== 'Enter');
} // Per: https://github.com/facebook/react/blob/3c713d513195a53788b3f8bb4b70279d68b15bcc/packages/react-interactions/events/src/dom/shared/index.js#L74-L87
// Keyboards, Assitive Technologies, and element.click() all produce a "virtual"
// click event. This is a method of inferring such clicks. Every browser except
// IE 11 only sets a zero value of "detail" for click events that are "virtual".
// However, IE 11 uses a zero value for all click events. For IE 11 we rely on
// the quirk that it produces click events that are of type PointerEvent, and
// where only the "virtual" click lacks a pointerType field.


function $d96e234a33d0fc61c9867cbf1a711$var$isVirtualClick(event) {
  // JAWS/NVDA with Firefox.
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }

  return event.detail === 0 && !event.pointerType;
}

function $d96e234a33d0fc61c9867cbf1a711$var$getTouchFromEvent(event) {
  var targetTouches = event.targetTouches;

  if (targetTouches.length > 0) {
    return targetTouches[0];
  }

  return null;
}

function $d96e234a33d0fc61c9867cbf1a711$var$getTouchById(event, pointerId) {
  var changedTouches = event.changedTouches;

  for (var i = 0; i < changedTouches.length; i++) {
    var touch = changedTouches[i];

    if (touch.identifier === pointerId) {
      return touch;
    }
  }

  return null;
}

function $d96e234a33d0fc61c9867cbf1a711$var$createEvent(target, e) {
  return {
    currentTarget: target,
    shiftKey: e.shiftKey,
    ctrlKey: e.ctrlKey,
    metaKey: e.metaKey
  };
}

function $d96e234a33d0fc61c9867cbf1a711$var$isOverTarget(point, target) {
  var rect = target.getBoundingClientRect();
  return (point.clientX || 0) >= (rect.left || 0) && (point.clientX || 0) <= (rect.right || 0) && (point.clientY || 0) >= (rect.top || 0) && (point.clientY || 0) <= (rect.bottom || 0);
}

function useInteractOutside(props) {
  var ref = props.ref,
      onInteractOutside = props.onInteractOutside;
  var stateRef = useRef({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  var state = stateRef.current;
  useEffect(function () {
    var onPointerDown = function onPointerDown(e) {
      if ($d4a49544db7051e6fc4a9e0a16b$var$isValidEvent(e, ref)) {
        state.isPointerDown = true;
      }
    }; // Use pointer events if available. Otherwise, fall back to mouse and touch events.


    if (typeof PointerEvent !== 'undefined') {
      var onPointerUp = function onPointerUp(e) {
        if (state.isPointerDown && onInteractOutside && $d4a49544db7051e6fc4a9e0a16b$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      document.addEventListener('pointerdown', onPointerDown, false);
      document.addEventListener('pointerup', onPointerUp, false);
      return function () {
        document.removeEventListener('pointerdown', onPointerDown, false);
        document.removeEventListener('pointerup', onPointerUp, false);
      };
    } else {
      var onMouseUp = function onMouseUp(e) {
        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
        } else if (state.isPointerDown && onInteractOutside && $d4a49544db7051e6fc4a9e0a16b$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      var onTouchEnd = function onTouchEnd(e) {
        state.ignoreEmulatedMouseEvents = true;

        if (onInteractOutside && state.isPointerDown && $d4a49544db7051e6fc4a9e0a16b$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      document.addEventListener('mousedown', onPointerDown, false);
      document.addEventListener('mouseup', onMouseUp, false);
      document.addEventListener('touchstart', onPointerDown, false);
      document.addEventListener('touchend', onTouchEnd, false);
      return function () {
        document.removeEventListener('mousedown', onPointerDown, false);
        document.removeEventListener('mouseup', onMouseUp, false);
        document.removeEventListener('touchstart', onPointerDown, false);
        document.removeEventListener('touchend', onTouchEnd, false);
      };
    }
  }, [onInteractOutside, ref, state.ignoreEmulatedMouseEvents, state.isPointerDown]);
}

exports.useInteractOutside = useInteractOutside;

function $d4a49544db7051e6fc4a9e0a16b$var$isValidEvent(event, ref) {
  if (event.button > 0) {
    return false;
  }

  return ref.current && !ref.current.contains(event.target);
}

var Pressable = _react.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      props = _babelRuntimeHelpersObjectWithoutProperties(_ref, ["children"]);

  ref = ref || useRef();

  var _usePress = usePress(_babelRuntimeHelpersObjectSpread({}, props, {
    ref: ref
  })),
      pressProps = _usePress.pressProps;

  var child = _react.Children.only(children);

  return _react.cloneElement(child, // @ts-ignore
  _babelRuntimeHelpersObjectSpread({
    ref: ref
  }, mergeProps(child.props, pressProps)));
});

exports.Pressable = Pressable;

var PressResponder = _react.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      props = _babelRuntimeHelpersObjectWithoutProperties(_ref, ["children"]);

  var isRegistered = useRef(false);

  var context = _babelRuntimeHelpersObjectSpread({}, props, {
    ref: ref,
    register: function register() {
      isRegistered.current = true;
    }
  });

  useEffect(function () {
    if (!isRegistered.current) {
      console.warn('A PressResponder was rendered without a pressable child. ' + 'Either call the usePress hook, or wrap your DOM node with <Pressable> component.');
    }
  }, []);
  return (/*#__PURE__*/_react.createElement($f0c946772fda863393a370b793f7614$export$PressResponderContext.Provider, {
      value: context
    }, children)
  );
});

exports.PressResponder = PressResponder;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// This function wraps a React event handler to make stopPropagation the default, and support continuePropagation instead.
function $d3f751924ed6dd36b5df9e3d348e5194$export$createEventHandler(handler) {
  if (!handler) {
    return;
  }

  var shouldStopPropagation = true;
  return function (e) {
    var event = _babelRuntimeHelpersObjectSpread({}, e, {
      preventDefault: function preventDefault() {
        e.preventDefault();
      },
      isDefaultPrevented: function isDefaultPrevented() {
        return e.isDefaultPrevented();
      },
      stopPropagation: function stopPropagation() {
        console.error('stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.');
      },
      continuePropagation: function continuePropagation() {
        shouldStopPropagation = false;
      }
    });

    handler(event);

    if (shouldStopPropagation) {
      e.stopPropagation();
    }
  };
}

function useKeyboard(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: $d3f751924ed6dd36b5df9e3d348e5194$export$createEventHandler(props.onKeyDown),
      onKeyUp: $d3f751924ed6dd36b5df9e3d348e5194$export$createEventHandler(props.onKeyUp)
    }
  };
}

exports.useKeyboard = useKeyboard;

/**
 * Handles focus events for the immediate target (no children)
 */
function useFocus(props) {
  if (props.isDisabled) {
    return {
      focusProps: {}
    };
  }

  var onFocus, onBlur;

  if (props.onFocus || props.onFocusChange) {
    onFocus = $d3f751924ed6dd36b5df9e3d348e5194$export$createEventHandler(function (e) {
      if (e.target === e.currentTarget) {
        if (props.onFocus) {
          props.onFocus(e);
        }

        if (props.onFocusChange) {
          props.onFocusChange(true);
        }
      }
    });
  }

  if (props.onBlur || props.onFocusChange) {
    onBlur = $d3f751924ed6dd36b5df9e3d348e5194$export$createEventHandler(function (e) {
      if (e.target === e.currentTarget) {
        if (props.onBlur) {
          props.onBlur(e);
        }

        if (props.onFocusChange) {
          props.onFocusChange(false);
        }
      }
    });
  }

  return {
    focusProps: {
      onFocus: onFocus,
      onBlur: onBlur
    }
  };
}

exports.useFocus = useFocus;

/**
 * Handles focus events for the target and all children
 */
function useFocusWithin(props) {
  var state = useRef({
    isFocusWithin: false
  }).current;

  if (props.isDisabled) {
    return {
      focusWithinProps: {}
    };
  }

  var onFocus = $d3f751924ed6dd36b5df9e3d348e5194$export$createEventHandler(function (e) {
    if (props.onFocusWithin) {
      props.onFocusWithin(e);
    }

    if (!state.isFocusWithin) {
      if (props.onFocusWithinChange) {
        props.onFocusWithinChange(true);
      }

      state.isFocusWithin = true;
    }
  });
  var onBlur = $d3f751924ed6dd36b5df9e3d348e5194$export$createEventHandler(function (e) {
    // We don't want to trigger onBlurWithin and then immediately onFocusWithin again 
    // when moving focus inside the element. Only trigger if the currentTarget doesn't 
    // include the relatedTarget (where focus is moving).
    if (state.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
      if (props.onBlurWithin) {
        props.onBlurWithin(e);
      }

      if (props.onFocusWithinChange) {
        props.onFocusWithinChange(false);
      }

      state.isFocusWithin = false;
    }
  });
  return {
    focusWithinProps: {
      onFocus: onFocus,
      onBlur: onBlur
    }
  };
}

exports.useFocusWithin = useFocusWithin;

function $cdeee53b9efe306c5345d332eb79788$var$_createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = $cdeee53b9efe306c5345d332eb79788$var$_unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (_e) {
          function e(_x) {
            return _e.apply(this, arguments);
          }

          e.toString = function () {
            return _e.toString();
          };

          return e;
        }(function (e) {
          throw e;
        }),
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (_e2) {
      function e(_x2) {
        return _e2.apply(this, arguments);
      }

      e.toString = function () {
        return _e2.toString();
      };

      return e;
    }(function (e) {
      didErr = true;
      err = e;
    }),
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function $cdeee53b9efe306c5345d332eb79788$var$_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return $cdeee53b9efe306c5345d332eb79788$var$_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $cdeee53b9efe306c5345d332eb79788$var$_arrayLikeToArray(o, minLen);
}

function $cdeee53b9efe306c5345d332eb79788$var$_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var $cdeee53b9efe306c5345d332eb79788$var$isGlobalFocusVisible = true;
var $cdeee53b9efe306c5345d332eb79788$var$changeHandlers = new Set();
var $cdeee53b9efe306c5345d332eb79788$var$hasSetupGlobalListeners = false;
var $cdeee53b9efe306c5345d332eb79788$var$hasEventBeforeFocus = false;
var $cdeee53b9efe306c5345d332eb79788$var$isMac = typeof window !== 'undefined' && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false; // Only Tab or Esc keys will make focus visible on text input elements

var $cdeee53b9efe306c5345d332eb79788$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};

function $cdeee53b9efe306c5345d332eb79788$var$triggerChangeHandlers(modality, e) {
  var _iterator = $cdeee53b9efe306c5345d332eb79788$var$_createForOfIteratorHelper($cdeee53b9efe306c5345d332eb79788$var$changeHandlers),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var handler = _step.value;
      handler(modality, e);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
} // Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible


function $cdeee53b9efe306c5345d332eb79788$var$isValidKey(e) {
  return !(e.metaKey || !$cdeee53b9efe306c5345d332eb79788$var$isMac && e.altKey || e.ctrlKey);
}

function $cdeee53b9efe306c5345d332eb79788$var$handleKeyboardEvent(e) {
  $cdeee53b9efe306c5345d332eb79788$var$hasEventBeforeFocus = true;

  if ($cdeee53b9efe306c5345d332eb79788$var$isValidKey(e)) {
    $cdeee53b9efe306c5345d332eb79788$var$isGlobalFocusVisible = true;
    $cdeee53b9efe306c5345d332eb79788$var$triggerChangeHandlers('keyboard', e);
  }
}

function $cdeee53b9efe306c5345d332eb79788$var$handlePointerEvent(e) {
  $cdeee53b9efe306c5345d332eb79788$var$isGlobalFocusVisible = false;

  if (e.type === 'mousedown' || e.type === 'pointerdown') {
    $cdeee53b9efe306c5345d332eb79788$var$hasEventBeforeFocus = true;
    $cdeee53b9efe306c5345d332eb79788$var$triggerChangeHandlers('pointer', e);
  }
}

function $cdeee53b9efe306c5345d332eb79788$var$handleFocusEvent(e) {
  // If a focus event occurs without a preceding keyboard or pointer event, switch to keyboard modality.
  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
  if (!$cdeee53b9efe306c5345d332eb79788$var$hasEventBeforeFocus) {
    $cdeee53b9efe306c5345d332eb79788$var$isGlobalFocusVisible = true;
    $cdeee53b9efe306c5345d332eb79788$var$triggerChangeHandlers('keyboard', e);
  }

  $cdeee53b9efe306c5345d332eb79788$var$hasEventBeforeFocus = false;
} // Setup global event listeners to control when keyboard focus style should be visible


function $cdeee53b9efe306c5345d332eb79788$var$setupGlobalFocusEvents() {
  if ($cdeee53b9efe306c5345d332eb79788$var$hasSetupGlobalListeners) {
    return;
  } // Programmatic focus() calls shouldn't affect the current input modality.
  // However, we need to detect other cases when a focus event occurs without
  // a preceding user event (e.g. screen reader focus). Overriding the focus
  // method on HTMLElement.prototype is a bit hacky, but works.


  var focus = HTMLElement.prototype.focus;

  HTMLElement.prototype.focus = function () {
    $cdeee53b9efe306c5345d332eb79788$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };

  document.addEventListener('keydown', $cdeee53b9efe306c5345d332eb79788$var$handleKeyboardEvent, true);
  document.addEventListener('keyup', $cdeee53b9efe306c5345d332eb79788$var$handleKeyboardEvent, true);
  document.addEventListener('focus', $cdeee53b9efe306c5345d332eb79788$var$handleFocusEvent, true);

  if (typeof PointerEvent !== 'undefined') {
    document.addEventListener('pointerdown', $cdeee53b9efe306c5345d332eb79788$var$handlePointerEvent, true);
    document.addEventListener('pointermove', $cdeee53b9efe306c5345d332eb79788$var$handlePointerEvent, true);
    document.addEventListener('pointerup', $cdeee53b9efe306c5345d332eb79788$var$handlePointerEvent, true);
  } else {
    document.addEventListener('mousedown', $cdeee53b9efe306c5345d332eb79788$var$handlePointerEvent, true);
    document.addEventListener('mousemove', $cdeee53b9efe306c5345d332eb79788$var$handlePointerEvent, true);
    document.addEventListener('mouseup', $cdeee53b9efe306c5345d332eb79788$var$handlePointerEvent, true);
  }

  $cdeee53b9efe306c5345d332eb79788$var$hasSetupGlobalListeners = true;
}
/**
 * Manages global focus visible state, and subscribes individual components for updates
 */


function useFocusVisible(props) {
  $cdeee53b9efe306c5345d332eb79788$var$setupGlobalFocusEvents();
  var isTextInput = props.isTextInput,
      autoFocus = props.autoFocus;

  var _useState = useState(autoFocus || $cdeee53b9efe306c5345d332eb79788$var$isGlobalFocusVisible),
      _useState2 = _babelRuntimeHelpersSlicedToArray(_useState, 2),
      isFocusVisible = _useState2[0],
      setFocusVisible = _useState2[1];

  useEffect(function () {
    var handler = function handler(modality, e) {
      // If this is a text input component, don't update the focus visible style when 
      // typing except for when the Tab and Escape keys are pressed.
      if (isTextInput && modality === 'keyboard' && !$cdeee53b9efe306c5345d332eb79788$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]) {
        return;
      }

      setFocusVisible($cdeee53b9efe306c5345d332eb79788$var$isGlobalFocusVisible);
    };

    $cdeee53b9efe306c5345d332eb79788$var$changeHandlers.add(handler);
    return function () {
      $cdeee53b9efe306c5345d332eb79788$var$changeHandlers.delete(handler);
    };
  }, [isTextInput]);
  return {
    isFocusVisible: isFocusVisible
  };
}

exports.useFocusVisible = useFocusVisible;

function useHover(props) {
  var onHover = props.onHover,
      onHoverChange = props.onHoverChange,
      onHoverEnd = props.onHoverEnd,
      isDisabled = props.isDisabled,
      domProps = _babelRuntimeHelpersObjectWithoutProperties(props, ["onHover", "onHoverChange", "onHoverEnd", "isDisabled"]);

  var hoverProps = useMemo(function () {
    var triggerHoverStart = function triggerHoverStart(event, pointerType) {
      if (isDisabled) {
        return;
      }

      if (pointerType === 'touch') {
        return;
      }

      var target = event.target;

      if (onHover) {
        onHover({
          type: 'hover',
          target: target,
          pointerType: pointerType
        });
      }

      if (onHoverChange) {
        onHoverChange(true);
      }
    };

    var triggerHoverEnd = function triggerHoverEnd(event, pointerType) {
      if (isDisabled) {
        return;
      }

      if (pointerType === 'touch') {
        return;
      }

      var target = event.target;

      if (onHoverEnd) {
        onHoverEnd({
          type: 'hoverend',
          target: target,
          pointerType: pointerType
        });
      }

      if (onHoverChange) {
        onHoverChange(false);
      }
    };

    var hoverProps = {};

    if (typeof PointerEvent !== 'undefined') {
      hoverProps.onPointerEnter = function (e) {
        triggerHoverStart(e, e.pointerType);
      };

      hoverProps.onPointerLeave = function (e) {
        triggerHoverEnd(e, e.pointerType);
      };
    } else {
      hoverProps.onMouseEnter = function (e) {
        triggerHoverStart(e, 'mouse');
      };

      hoverProps.onMouseLeave = function (e) {
        triggerHoverEnd(e, 'mouse');
      };
    }

    return hoverProps;
  }, [onHover, onHoverChange, onHoverEnd, isDisabled]);
  return {
    hoverProps: mergeProps(domProps, hoverProps)
  };
}

exports.useHover = useHover;

var DOMPropsResponderContext = _react.createContext(null);

exports.DOMPropsResponderContext = DOMPropsResponderContext;

function useDOMPropsResponderContext(props) {
  // Consume context from <DOMPropsResponder> and merge with props.
  var context = useContext(DOMPropsResponderContext);

  if (context) {
    var _register = context.register,
        contextProps = _babelRuntimeHelpersObjectWithoutProperties(context, ["register"]);

    props = mergeProps(contextProps, props);

    _register();
  } // Sync ref from <DOMPropsResponder> with ref passed to the useHover hook.


  useEffect(function () {
    if (context && context.ref) {
      context.ref.current = props.ref.current;
      return function () {
        context.ref.current = null;
      };
    }
  }, [context, props.ref]);
  return props;
}

exports.useDOMPropsResponderContext = useDOMPropsResponderContext;

var DOMPropsResponder = _react.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      props = _babelRuntimeHelpersObjectWithoutProperties(_ref, ["children"]);

  var isRegistered = useRef(false);

  var context = _babelRuntimeHelpersObjectSpread({}, props, {
    ref: ref,
    register: function register() {
      isRegistered.current = true;
    }
  }); // TODO: Think of a more generic message when this replaces the PressResponder as well


  useEffect(function () {
    if (!isRegistered.current) {
      console.warn('A DOMPropsResponder was ultilized without a hoverable DOM node.');
    }
  }, []);
  return (/*#__PURE__*/_react.createElement(DOMPropsResponderContext.Provider, {
      value: context
    }, children)
  );
});

exports.DOMPropsResponder = DOMPropsResponder;

function useDOMPropsResponder(domRef) {
  var domProps = useDOMPropsResponderContext({
    ref: domRef
  }) || {}; // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars

  var register = domProps.register,
      isDisabled = domProps.isDisabled,
      onPress = domProps.onPress,
      partialDomProps = _babelRuntimeHelpersObjectWithoutProperties(domProps, ["register", "isDisabled", "onPress"]);

  return {
    contextProps: partialDomProps
  };
}

exports.useDOMPropsResponder = useDOMPropsResponder;