import { useLayoutEffect, useMemo, useState, useRef, useEffect } from "react";
import _classnames from "classnames";
let $cd19650f495ff8ac1e00dac56402ca3$var$map = new Map();
let $cd19650f495ff8ac1e00dac56402ca3$var$id = 0; // don't want to conflict with ids from v2, this will guarantee something unique
// plus we'll know how many instances of this module are loaded on a page if there are more than one number ;)

let $cd19650f495ff8ac1e00dac56402ca3$var$randomInstanceNumber = Math.round(Math.random() * 10000000000);
export function useId(defaultId) {
  let [value, setValue] = useState(defaultId);
  let res = useMemo(() => value || "react-spectrum-".concat($cd19650f495ff8ac1e00dac56402ca3$var$randomInstanceNumber, "-").concat(++$cd19650f495ff8ac1e00dac56402ca3$var$id), [value]);
  $cd19650f495ff8ac1e00dac56402ca3$var$map.set(res, setValue);
  return res;
}
export function mergeIds(a, b) {
  if (a === b) {
    return a;
  }

  let setA = $cd19650f495ff8ac1e00dac56402ca3$var$map.get(a);

  if (setA) {
    setA(b);
    return b;
  }

  let setB = $cd19650f495ff8ac1e00dac56402ca3$var$map.get(b);

  if (setB) {
    setB(a);
    return a;
  }

  return b;
}
export function useSlotId() {
  let [id, setId] = useState(useId());
  useLayoutEffect(() => {
    let setCurr = $cd19650f495ff8ac1e00dac56402ca3$var$map.get(id);

    if (setCurr && !document.getElementById(id)) {
      setId(null);
    }
  }, [id]);
  return id;
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
export function chain(...callbacks) {
  return (...args) => {
    for (let callback of callbacks) {
      if (typeof callback === 'function') {
        callback(...args);
      }
    }
  };
}
export function mergeProps(a, b) {
  let res = {};

  for (let key in a) {
    // Chain events
    if (/^on[A-Z]/.test(key) && typeof a[key] === 'function' && typeof b[key] === 'function') {
      res[key] = chain(a[key], b[key]); // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check
    } else if (key === 'className' && typeof a.className === 'string' && typeof b.className === 'string') {
      res[key] = _classnames(a.className, b.className);
    } else if (key === 'UNSAFE_className' && typeof a.UNSAFE_className === 'string' && typeof b.UNSAFE_className === 'string') {
      res[key] = _classnames(a.UNSAFE_className, b.UNSAFE_className);
    } else if (key === 'id' && a.id && b.id) {
      res.id = mergeIds(a.id, b.id); // Override others
    } else {
      res[key] = b[key] !== undefined ? b[key] : a[key];
    }
  } // Add props from b that are not in a


  for (let key in b) {
    if (a[key] === undefined) {
      res[key] = b[key];
    }
  }

  return res;
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
export function clamp(value, min = -Infinity, max = Infinity) {
  return Math.min(Math.max(value, min), max);
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
export function getOffset(element, reverse, orientation = 'horizontal') {
  let rect = element.getBoundingClientRect();

  if (reverse) {
    return orientation === 'horizontal' ? rect.right : rect.bottom;
  }

  return orientation === 'horizontal' ? rect.left : rect.top;
}
// created for splitview, this should be reusable for things like sliders/dials
// It also handles keyboard events on the target allowing for increment/decrement by a given stepsize as well as minifying/maximizing and toggling between minified and previous size
// It can also take a 'reverse' param to say if we should measure from the right/bottom instead of the top/left
// It can also handle either a vertical or horizontal movement, but not both at the same time
export function useDrag1D(props) {
  let {
    containerRef,
    reverse,
    orientation,
    onHover,
    onDrag,
    onPositionChange,
    onIncrement,
    onDecrement,
    onIncrementToMax,
    onDecrementToMin,
    onCollapseToggle
  } = props;

  let getPosition = e => orientation === 'horizontal' ? e.clientX : e.clientY;

  let getNextOffset = e => {
    let containerOffset = getOffset(containerRef.current, reverse, orientation);
    let mouseOffset = getPosition(e);
    let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
    return nextOffset;
  };

  let dragging = useRef(false);
  let prevPosition = useRef(0);

  let onMouseDragged = e => {
    e.preventDefault();
    let nextOffset = getNextOffset(e);

    if (!dragging.current) {
      dragging.current = true;

      if (onDrag) {
        onDrag(true);
      }

      if (onPositionChange) {
        onPositionChange(nextOffset);
      }
    }

    if (prevPosition.current === nextOffset) {
      return;
    }

    prevPosition.current = nextOffset;

    if (onPositionChange) {
      onPositionChange(nextOffset);
    }
  };

  let onMouseUp = e => {
    dragging.current = false;
    let nextOffset = getNextOffset(e);

    if (onDrag) {
      onDrag(false);
    }

    if (onPositionChange) {
      onPositionChange(nextOffset);
    }

    window.removeEventListener('mouseup', onMouseUp, false);
    window.removeEventListener('mousemove', onMouseDragged, false);
  };

  let onMouseDown = () => {
    window.addEventListener('mousemove', onMouseDragged, false);
    window.addEventListener('mouseup', onMouseUp, false);
  };

  let onMouseEnter = () => {
    if (onHover) {
      onHover(true);
    }
  };

  let onMouseOut = () => {
    if (onHover) {
      onHover(false);
    }
  };

  let onKeyDown = e => {
    e.preventDefault();

    switch (e.key) {
      case 'Left':
      case 'ArrowLeft':
        if (orientation === 'horizontal') {
          if (onDecrement && !reverse) {
            onDecrement();
          } else if (onIncrement && reverse) {
            onIncrement();
          }
        }

        break;

      case 'Up':
      case 'ArrowUp':
        if (orientation === 'vertical') {
          if (onDecrement && !reverse) {
            onDecrement();
          } else if (onIncrement && reverse) {
            onIncrement();
          }
        }

        break;

      case 'Right':
      case 'ArrowRight':
        if (orientation === 'horizontal') {
          if (onIncrement && !reverse) {
            onIncrement();
          } else if (onDecrement && reverse) {
            onDecrement();
          }
        }

        break;

      case 'Down':
      case 'ArrowDown':
        if (orientation === 'vertical') {
          if (onIncrement && !reverse) {
            onIncrement();
          } else if (onDecrement && reverse) {
            onDecrement();
          }
        }

        break;

      case 'Home':
        if (onDecrementToMin) {
          onDecrementToMin();
        }

        break;

      case 'End':
        if (onIncrementToMax) {
          onIncrementToMax();
        }

        break;

      case 'Enter':
        if (onCollapseToggle) {
          onCollapseToggle();
        }

        break;
    }
  };

  return {
    onMouseDown,
    onMouseEnter,
    onMouseOut,
    onKeyDown
  };
}
export function useLabels(props, defaultLabel) {
  let {
    id,
    'aria-label': label,
    'aria-labelledby': labelledBy
  } = props; // If there is both an aria-label and aria-labelledby, 
  // combine them by pointing to the element itself.

  id = useId(id);

  if (labelledBy && label) {
    let ids = new Set([...labelledBy.trim().split(/\s+/), id]);
    labelledBy = [...ids].join(' ');
  } else if (labelledBy) {
    labelledBy = labelledBy.trim().split(/\s+/).join(' ');
  } // If no labels are provided, use the default


  if (!label && !labelledBy && defaultLabel) {
    label = defaultLabel;
  }

  return {
    id,
    'aria-label': label,
    'aria-labelledby': labelledBy
  };
}
// Like useEffect, but only called for updates after the initial render.
export function useUpdateEffect(effect, dependencies) {
  const isInitialMount = useRef(true);
  useEffect(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false;
    } else {
      effect();
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, dependencies);
}
// This is a polyfill for element.focus({preventScroll: true});
// Currently necessary for Safari and old Edge:
// https://caniuse.com/#feat=mdn-api_htmlelement_focus_preventscroll_option
// See https://bugs.webkit.org/show_bug.cgi?id=178583
//
// Heavily based on https://github.com/calvellido/focus-options-polyfill
export function focusWithoutScrolling(element) {
  if ($ac08b12e470ae7eec1071d5c603$var$supportsPreventScroll()) {
    element.focus({
      preventScroll: true
    });
  } else {
    let scrollableElements = $ac08b12e470ae7eec1071d5c603$var$getScrollableElements(element);
    element.focus();
    $ac08b12e470ae7eec1071d5c603$var$restoreScrollPosition(scrollableElements);
  }
}
let $ac08b12e470ae7eec1071d5c603$var$supportsPreventScrollCached = null;

function $ac08b12e470ae7eec1071d5c603$var$supportsPreventScroll() {
  if ($ac08b12e470ae7eec1071d5c603$var$supportsPreventScrollCached == null) {
    $ac08b12e470ae7eec1071d5c603$var$supportsPreventScrollCached = false;

    try {
      var focusElem = document.createElement('div');
      focusElem.focus({
        get preventScroll() {
          $ac08b12e470ae7eec1071d5c603$var$supportsPreventScrollCached = true;
          return true;
        }

      });
    } catch (e) {// Ignore
    }
  }

  return $ac08b12e470ae7eec1071d5c603$var$supportsPreventScrollCached;
}

function $ac08b12e470ae7eec1071d5c603$var$getScrollableElements(element) {
  var parent = element.parentNode;
  var scrollableElements = [];
  var rootScrollingElement = document.scrollingElement || document.documentElement;

  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    }

    parent = parent.parentNode;
  }

  if (rootScrollingElement instanceof HTMLElement) {
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  }

  return scrollableElements;
}

function $ac08b12e470ae7eec1071d5c603$var$restoreScrollPosition(scrollableElements) {
  for (let {
    element,
    scrollTop,
    scrollLeft
  } of scrollableElements) {
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}