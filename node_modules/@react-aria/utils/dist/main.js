var _babelRuntimeHelpersSlicedToArray = $parcel$interopDefault(require("@babel/runtime/helpers/slicedToArray"));

var _temp = require("react");

var useLayoutEffect = _temp.useLayoutEffect;
var useMemo = _temp.useMemo;
var useState = _temp.useState;
var useRef = _temp.useRef;
var useEffect = _temp.useEffect;

var _classnames = $parcel$interopDefault(require("classnames"));

var _babelRuntimeHelpersToConsumableArray = $parcel$interopDefault(require("@babel/runtime/helpers/toConsumableArray"));

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

var $dd2a6808931b40a634ed036e6f4c03b$var$map = new Map();
var $dd2a6808931b40a634ed036e6f4c03b$var$id = 0; // don't want to conflict with ids from v2, this will guarantee something unique
// plus we'll know how many instances of this module are loaded on a page if there are more than one number ;)

var $dd2a6808931b40a634ed036e6f4c03b$var$randomInstanceNumber = Math.round(Math.random() * 10000000000);

function useId(defaultId) {
  var _useState = useState(defaultId),
      _useState2 = _babelRuntimeHelpersSlicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var res = useMemo(function () {
    return value || "react-spectrum-".concat($dd2a6808931b40a634ed036e6f4c03b$var$randomInstanceNumber, "-").concat(++$dd2a6808931b40a634ed036e6f4c03b$var$id);
  }, [value]);
  $dd2a6808931b40a634ed036e6f4c03b$var$map.set(res, setValue);
  return res;
}

exports.useId = useId;

function mergeIds(a, b) {
  if (a === b) {
    return a;
  }

  var setA = $dd2a6808931b40a634ed036e6f4c03b$var$map.get(a);

  if (setA) {
    setA(b);
    return b;
  }

  var setB = $dd2a6808931b40a634ed036e6f4c03b$var$map.get(b);

  if (setB) {
    setB(a);
    return a;
  }

  return b;
}

exports.mergeIds = mergeIds;

function useSlotId() {
  var _useState3 = useState(useId()),
      _useState4 = _babelRuntimeHelpersSlicedToArray(_useState3, 2),
      id = _useState4[0],
      setId = _useState4[1];

  useLayoutEffect(function () {
    var setCurr = $dd2a6808931b40a634ed036e6f4c03b$var$map.get(id);

    if (setCurr && !document.getElementById(id)) {
      setId(null);
    }
  }, [id]);
  return id;
}

exports.useSlotId = useSlotId;

function $d3cd28c168b10827abf6318f227022b0$var$_createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = $d3cd28c168b10827abf6318f227022b0$var$_unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function $d3cd28c168b10827abf6318f227022b0$var$_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return $d3cd28c168b10827abf6318f227022b0$var$_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $d3cd28c168b10827abf6318f227022b0$var$_arrayLikeToArray(o, minLen);
}

function $d3cd28c168b10827abf6318f227022b0$var$_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


function chain() {
  for (var _len = arguments.length, callbacks = new Array(_len), _key = 0; _key < _len; _key++) {
    callbacks[_key] = arguments[_key];
  }

  return function () {
    var _iterator = $d3cd28c168b10827abf6318f227022b0$var$_createForOfIteratorHelper(callbacks),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var callback = _step.value;

        if (typeof callback === 'function') {
          callback.apply(void 0, arguments);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
}

exports.chain = chain;

function mergeProps(a, b) {
  var res = {};

  for (var _key in a) {
    // Chain events
    if (/^on[A-Z]/.test(_key) && typeof a[_key] === 'function' && typeof b[_key] === 'function') {
      res[_key] = chain(a[_key], b[_key]); // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check
    } else if (_key === 'className' && typeof a.className === 'string' && typeof b.className === 'string') {
      res[_key] = _classnames(a.className, b.className);
    } else if (_key === 'UNSAFE_className' && typeof a.UNSAFE_className === 'string' && typeof b.UNSAFE_className === 'string') {
      res[_key] = _classnames(a.UNSAFE_className, b.UNSAFE_className);
    } else if (_key === 'id' && a.id && b.id) {
      res.id = mergeIds(a.id, b.id); // Override others
    } else {
      res[_key] = b[_key] !== undefined ? b[_key] : a[_key];
    }
  } // Add props from b that are not in a


  for (var _key2 in b) {
    if (a[_key2] === undefined) {
      res[_key2] = b[_key2];
    }
  }

  return res;
}

exports.mergeProps = mergeProps;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
function clamp(value) {
  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;
  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  return Math.min(Math.max(value, min), max);
}

exports.clamp = clamp;

function getOffset(element, reverse) {
  var orientation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'horizontal';
  var rect = element.getBoundingClientRect();

  if (reverse) {
    return orientation === 'horizontal' ? rect.right : rect.bottom;
  }

  return orientation === 'horizontal' ? rect.left : rect.top;
}

exports.getOffset = getOffset;

// created for splitview, this should be reusable for things like sliders/dials
// It also handles keyboard events on the target allowing for increment/decrement by a given stepsize as well as minifying/maximizing and toggling between minified and previous size
// It can also take a 'reverse' param to say if we should measure from the right/bottom instead of the top/left
// It can also handle either a vertical or horizontal movement, but not both at the same time
function useDrag1D(props) {
  var containerRef = props.containerRef,
      reverse = props.reverse,
      orientation = props.orientation,
      onHover = props.onHover,
      onDrag = props.onDrag,
      onPositionChange = props.onPositionChange,
      onIncrement = props.onIncrement,
      onDecrement = props.onDecrement,
      onIncrementToMax = props.onIncrementToMax,
      onDecrementToMin = props.onDecrementToMin,
      onCollapseToggle = props.onCollapseToggle;

  var getPosition = function getPosition(e) {
    return orientation === 'horizontal' ? e.clientX : e.clientY;
  };

  var getNextOffset = function getNextOffset(e) {
    var containerOffset = getOffset(containerRef.current, reverse, orientation);
    var mouseOffset = getPosition(e);
    var nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
    return nextOffset;
  };

  var dragging = useRef(false);
  var prevPosition = useRef(0);

  var onMouseDragged = function onMouseDragged(e) {
    e.preventDefault();
    var nextOffset = getNextOffset(e);

    if (!dragging.current) {
      dragging.current = true;

      if (onDrag) {
        onDrag(true);
      }

      if (onPositionChange) {
        onPositionChange(nextOffset);
      }
    }

    if (prevPosition.current === nextOffset) {
      return;
    }

    prevPosition.current = nextOffset;

    if (onPositionChange) {
      onPositionChange(nextOffset);
    }
  };

  var onMouseUp = function onMouseUp(e) {
    dragging.current = false;
    var nextOffset = getNextOffset(e);

    if (onDrag) {
      onDrag(false);
    }

    if (onPositionChange) {
      onPositionChange(nextOffset);
    }

    window.removeEventListener('mouseup', onMouseUp, false);
    window.removeEventListener('mousemove', onMouseDragged, false);
  };

  var onMouseDown = function onMouseDown() {
    window.addEventListener('mousemove', onMouseDragged, false);
    window.addEventListener('mouseup', onMouseUp, false);
  };

  var onMouseEnter = function onMouseEnter() {
    if (onHover) {
      onHover(true);
    }
  };

  var onMouseOut = function onMouseOut() {
    if (onHover) {
      onHover(false);
    }
  };

  var onKeyDown = function onKeyDown(e) {
    e.preventDefault();

    switch (e.key) {
      case 'Left':
      case 'ArrowLeft':
        if (orientation === 'horizontal') {
          if (onDecrement && !reverse) {
            onDecrement();
          } else if (onIncrement && reverse) {
            onIncrement();
          }
        }

        break;

      case 'Up':
      case 'ArrowUp':
        if (orientation === 'vertical') {
          if (onDecrement && !reverse) {
            onDecrement();
          } else if (onIncrement && reverse) {
            onIncrement();
          }
        }

        break;

      case 'Right':
      case 'ArrowRight':
        if (orientation === 'horizontal') {
          if (onIncrement && !reverse) {
            onIncrement();
          } else if (onDecrement && reverse) {
            onDecrement();
          }
        }

        break;

      case 'Down':
      case 'ArrowDown':
        if (orientation === 'vertical') {
          if (onIncrement && !reverse) {
            onIncrement();
          } else if (onDecrement && reverse) {
            onDecrement();
          }
        }

        break;

      case 'Home':
        if (onDecrementToMin) {
          onDecrementToMin();
        }

        break;

      case 'End':
        if (onIncrementToMax) {
          onIncrementToMax();
        }

        break;

      case 'Enter':
        if (onCollapseToggle) {
          onCollapseToggle();
        }

        break;
    }
  };

  return {
    onMouseDown: onMouseDown,
    onMouseEnter: onMouseEnter,
    onMouseOut: onMouseOut,
    onKeyDown: onKeyDown
  };
}

exports.useDrag1D = useDrag1D;

function useLabels(props, defaultLabel) {
  var id = props.id,
      label = props['aria-label'],
      labelledBy = props['aria-labelledby']; // If there is both an aria-label and aria-labelledby, 
  // combine them by pointing to the element itself.

  id = useId(id);

  if (labelledBy && label) {
    var ids = new Set([].concat(_babelRuntimeHelpersToConsumableArray(labelledBy.trim().split(/\s+/)), [id]));
    labelledBy = _babelRuntimeHelpersToConsumableArray(ids).join(' ');
  } else if (labelledBy) {
    labelledBy = labelledBy.trim().split(/\s+/).join(' ');
  } // If no labels are provided, use the default


  if (!label && !labelledBy && defaultLabel) {
    label = defaultLabel;
  }

  return {
    id: id,
    'aria-label': label,
    'aria-labelledby': labelledBy
  };
}

exports.useLabels = useLabels;

// Like useEffect, but only called for updates after the initial render.
function useUpdateEffect(effect, dependencies) {
  var isInitialMount = useRef(true);
  useEffect(function () {
    if (isInitialMount.current) {
      isInitialMount.current = false;
    } else {
      effect();
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, dependencies);
}

exports.useUpdateEffect = useUpdateEffect;

function $a5287697384fb579cdf94b55b288b$var$_createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = $a5287697384fb579cdf94b55b288b$var$_unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function $a5287697384fb579cdf94b55b288b$var$_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return $a5287697384fb579cdf94b55b288b$var$_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $a5287697384fb579cdf94b55b288b$var$_arrayLikeToArray(o, minLen);
}

function $a5287697384fb579cdf94b55b288b$var$_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// This is a polyfill for element.focus({preventScroll: true});
// Currently necessary for Safari and old Edge:
// https://caniuse.com/#feat=mdn-api_htmlelement_focus_preventscroll_option
// See https://bugs.webkit.org/show_bug.cgi?id=178583
//
// Heavily based on https://github.com/calvellido/focus-options-polyfill


function focusWithoutScrolling(element) {
  if ($a5287697384fb579cdf94b55b288b$var$supportsPreventScroll()) {
    element.focus({
      preventScroll: true
    });
  } else {
    var scrollableElements = $a5287697384fb579cdf94b55b288b$var$getScrollableElements(element);
    element.focus();
    $a5287697384fb579cdf94b55b288b$var$restoreScrollPosition(scrollableElements);
  }
}

exports.focusWithoutScrolling = focusWithoutScrolling;
var $a5287697384fb579cdf94b55b288b$var$supportsPreventScrollCached = null;

function $a5287697384fb579cdf94b55b288b$var$supportsPreventScroll() {
  if ($a5287697384fb579cdf94b55b288b$var$supportsPreventScrollCached == null) {
    $a5287697384fb579cdf94b55b288b$var$supportsPreventScrollCached = false;

    try {
      var focusElem = document.createElement('div');
      focusElem.focus({
        get preventScroll() {
          $a5287697384fb579cdf94b55b288b$var$supportsPreventScrollCached = true;
          return true;
        }

      });
    } catch (e) {// Ignore
    }
  }

  return $a5287697384fb579cdf94b55b288b$var$supportsPreventScrollCached;
}

function $a5287697384fb579cdf94b55b288b$var$getScrollableElements(element) {
  var parent = element.parentNode;
  var scrollableElements = [];
  var rootScrollingElement = document.scrollingElement || document.documentElement;

  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    }

    parent = parent.parentNode;
  }

  if (rootScrollingElement instanceof HTMLElement) {
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  }

  return scrollableElements;
}

function $a5287697384fb579cdf94b55b288b$var$restoreScrollPosition(scrollableElements) {
  var _iterator = $a5287697384fb579cdf94b55b288b$var$_createForOfIteratorHelper(scrollableElements),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _step.value,
          element = _step$value.element,
          scrollTop = _step$value.scrollTop,
          scrollLeft = _step$value.scrollLeft;
      element.scrollTop = scrollTop;
      element.scrollLeft = scrollLeft;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}